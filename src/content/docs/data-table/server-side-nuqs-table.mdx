---
title: Server-Side Nuqs Table
description: Server-side pagination, sorting, and filtering with TanStack Query and URL state persistence using nuqs.
---

import CodePreview from "@/components/markdown/code-preview/code-preview.astro"

<CodePreview demo="data-table/server-side-nuqs-state" />

## Introduction

The Server-Side Nuqs Table demonstrates server-side pagination, sorting, and filtering using [TanStack Query](https://tanstack.com/query/latest) for efficient data fetching, caching, and state management, combined with [nuqs](https://nuqs.dev/) for URL state persistence. This example shows how to handle large datasets by fetching data from a server with automatic caching, background updates, and request deduplication, while maintaining all table state in the URL for bookmarkable and shareable views.

## Installation

1. Add the required components:

```bash
npx shadcn@latest add table input button dropdown-menu popover command checkbox select scroll-area separator skeleton tooltip
```

2. Add dependencies:

```bash
npm install @tanstack/react-table @tanstack/react-query nuqs
```

**Note:**

- [TanStack Query](https://tanstack.com/query/latest) provides powerful asynchronous state management, server-state utilities, and data fetching capabilities. It handles caching, background updates, and stale data out of the box with zero-configuration.
- [nuqs](https://nuqs.dev/) enables URL state persistence, making table views bookmarkable and shareable.

**Required: Sortable Component**

This example uses `DataTableSortMenu` and `DataTableFilterMenu` which require the Sortable component for drag-and-drop reordering. Follow the [DiceUI Sortable installation guide](https://www.diceui.com/docs/components/sortable).

3. Copy the DataTable components into your project. See the [Installation Guide](/getting-started/installation) for detailed instructions.

## Setup

Before using the Server-Side Table + Nuqs, you need to wrap your app with both `QueryClientProvider` and `NuqsAdapter`. Follow the setup instructions based on your framework:

### Next.js App Router

Wrap `{children}` in `app/layout.tsx`:

```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { NuqsAdapter } from "nuqs/adapters/next/app"

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000, // 1 minute
      refetchOnWindowFocus: false,
    },
  },
})

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <QueryClientProvider client={queryClient}>
          <NuqsAdapter>{children}</NuqsAdapter>
        </QueryClientProvider>
      </body>
    </html>
  )
}
```

### Next.js Pages Router

Wrap `<Component>` in `pages/_app.tsx`:

```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { NuqsAdapter } from "nuqs/adapters/next/pages"

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000,
      refetchOnWindowFocus: false,
    },
  },
})

export default function App({ Component, pageProps }) {
  return (
    <QueryClientProvider client={queryClient}>
      <NuqsAdapter>
        <Component {...pageProps} />
      </NuqsAdapter>
    </QueryClientProvider>
  )
}
```

### React SPA (Vite, CRA, etc.)

Wrap `<App />` in `src/main.tsx`:

```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { NuqsAdapter } from "nuqs/adapters/react"

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000,
      refetchOnWindowFocus: false,
    },
  },
})

createRoot(document.getElementById("root")!).render(
  <QueryClientProvider client={queryClient}>
    <NuqsAdapter>
      <App />
    </NuqsAdapter>
  </QueryClientProvider>,
)
```

## Prerequisites

We are going to build a table with server-side data fetching. Here's what our data structure looks like:

```tsx showLineNumbers
type Product = {
  id: string
  name: string
  category: string
  brand: string
  price: number
  stock: number
  rating: number
  inStock: boolean
  releaseDate: Date
}
```

## Server-Side Data Fetching

The example uses TanStack Query's `useQuery` hook to fetch data from a server. The query automatically refetches when pagination, sorting, or filters change.

### API Function

First, create a function that fetches data from your server:

```tsx showLineNumbers title="api.ts"
type ServerResponse<T> = {
  data: T[]
  total: number
  page: number
  pageSize: number
}

type FetchParams = {
  page: number
  pageSize: number
  sorting: SortingState
  globalFilter: string | object
  columnFilters: ColumnFiltersState
}

async function fetchProducts(
  params: FetchParams,
): Promise<ServerResponse<Product>> {
  // Build query string from params
  const queryParams = new URLSearchParams({
    page: params.page.toString(),
    pageSize: params.pageSize.toString(),
    sort: JSON.stringify(params.sorting),
    filters: JSON.stringify(params.columnFilters),
    search: typeof params.globalFilter === "string" ? params.globalFilter : "",
  })

  const response = await fetch(`/api/products?${queryParams}`)
  if (!response.ok) {
    throw new Error("Failed to fetch products")
  }

  return response.json()
}
```

### Using TanStack Query

Use `useQuery` to fetch data with automatic caching and refetching:

```tsx showLineNumbers title="server-side-nuqs-state.tsx"
import { useQuery } from "@tanstack/react-query"
import type { SortingState, ColumnFiltersState } from "@tanstack/react-table"

function ServerSideTable() {
  const [pagination, setPagination] = useState({ pageIndex: 0, pageSize: 10 })
  const [sorting, setSorting] = useState<SortingState>([])
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([])
  const [globalFilter, setGlobalFilter] = useState<string | object>("")

  const { data, isLoading, error } = useQuery({
    queryKey: [
      "products",
      pagination.pageIndex,
      pagination.pageSize,
      sorting,
      globalFilter,
      columnFilters,
    ],
    queryFn: () =>
      fetchProducts({
        page: pagination.pageIndex,
        pageSize: pagination.pageSize,
        sorting,
        globalFilter,
        columnFilters,
      }),
    staleTime: 30000, // Consider data fresh for 30 seconds
    gcTime: 5 * 60 * 1000, // Keep in cache for 5 minutes
  })

  const products = data?.data ?? []
  const totalCount = data?.total ?? 0

  return (
    <DataTableRoot
      data={products}
      columns={columns}
      isLoading={isLoading}
      config={{
        manualPagination: true,
        manualFiltering: true,
        manualSorting: true,
        pageCount: Math.ceil(totalCount / pagination.pageSize),
      }}
      state={{
        pagination,
        sorting,
        columnFilters,
        globalFilter,
      }}
      onPaginationChange={setPagination}
      onSortingChange={setSorting}
      onColumnFiltersChange={setColumnFilters}
      onGlobalFilterChange={setGlobalFilter}
    >
      {/* Table components */}
    </DataTableRoot>
  )
}
```

## Key Features

### Automatic Caching

TanStack Query automatically caches query results. When you navigate between pages and come back, the data is served from cache instantly.

### Background Refetching

Data is automatically refetched in the background when it becomes stale, keeping your UI up-to-date without user intervention.

### Request Deduplication

Multiple components requesting the same data will share a single request, reducing server load.

### Loading States

TanStack Query provides `isLoading` and `isFetching` states:

- `isLoading`: True on initial load (no cached data)
- `isFetching`: True whenever a request is in progress (including background refetches)

```tsx showLineNumbers
const { data, isLoading, isFetching } = useQuery({ ... })

// Show skeleton on initial load
{isLoading && <DataTableSkeleton rows={10} />}

// Show subtle indicator during background refetch
{isFetching && !isLoading && <LoadingIndicator />}
```

### Prefetching Next/Previous Pages

To improve navigation performance, you can prefetch adjacent pages in the background. This makes page transitions feel instant when users navigate. You can also track prefetching state to show visual feedback to users:

```tsx showLineNumbers
import { useQueryClient } from "@tanstack/react-query"
import { useEffect, useState, useRef } from "react"
import { Loader2 } from "lucide-react"

function ServerSideNuqsTable() {
  const queryClient = useQueryClient()
  const [urlParams, setUrlParams] = useQueryStates(tableStateParsers)
  // ... other state

  // Track prefetching state for UI feedback
  const [prefetchingState, setPrefetchingState] = useState<{
    next: boolean
    previous: boolean
  }>({ next: false, previous: false })
  const effectRunRef = useRef(0)

  // Prefetch next and previous pages
  useEffect(() => {
    const totalPages = Math.ceil(totalCount / urlParams.pageSize)
    const currentPage = urlParams.pageIndex
    const currentRun = ++effectRunRef.current

    // Reset prefetching state at the start of each effect run
    setTimeout(() => {
      if (currentRun === effectRunRef.current) {
        setPrefetchingState({ next: false, previous: false })
      }
    }, 0)

    // Prefetch next page if it exists
    if (currentPage + 1 < totalPages) {
      setTimeout(() => {
        if (currentRun === effectRunRef.current) {
          setPrefetchingState(prev => ({ ...prev, next: true }))
        }
      }, 0)

      queryClient
        .prefetchQuery({
          queryKey: [
            "products",
            currentPage + 1,
            urlParams.pageSize,
            urlParams.sort,
            urlParams.globalFilter,
            urlParams.filters,
            urlParams.filterMode,
          ],
          queryFn: () =>
            fetchProducts({
              page: currentPage + 1,
              pageSize: urlParams.pageSize,
              sorting: urlParams.sort,
              globalFilter: urlParams.globalFilter,
              columnFilters: urlParams.filters,
            }),
          staleTime: 30000,
        })
        .then(() => {
          if (currentRun === effectRunRef.current) {
            setPrefetchingState(prev => ({ ...prev, next: false }))
          }
        })
        .catch(() => {
          if (currentRun === effectRunRef.current) {
            setPrefetchingState(prev => ({ ...prev, next: false }))
          }
        })
    }

    // Prefetch previous page if it exists
    if (currentPage > 0) {
      setTimeout(() => {
        if (currentRun === effectRunRef.current) {
          setPrefetchingState(prev => ({ ...prev, previous: true }))
        }
      }, 0)

      queryClient
        .prefetchQuery({
          queryKey: [
            "products",
            currentPage - 1,
            urlParams.pageSize,
            urlParams.sort,
            urlParams.globalFilter,
            urlParams.filters,
            urlParams.filterMode,
          ],
          queryFn: () =>
            fetchProducts({
              page: currentPage - 1,
              pageSize: urlParams.pageSize,
              sorting: urlParams.sort,
              globalFilter: urlParams.globalFilter,
              columnFilters: urlParams.filters,
            }),
          staleTime: 30000,
        })
        .then(() => {
          if (currentRun === effectRunRef.current) {
            setPrefetchingState(prev => ({ ...prev, previous: false }))
          }
        })
        .catch(() => {
          if (currentRun === effectRunRef.current) {
            setPrefetchingState(prev => ({ ...prev, previous: false }))
          }
        })
    }

    // Cleanup function: reset state if effect re-runs
    return () => {
      setPrefetchingState({ next: false, previous: false })
    }
  }, [
    queryClient,
    urlParams.pageIndex,
    urlParams.pageSize,
    urlParams.sort,
    urlParams.globalFilter,
    urlParams.filters,
    urlParams.filterMode,
    totalCount,
  ])

  return (
    <div>
      {/* Show prefetching indicators */}
      {prefetchingState.next && (
        <div className="flex items-center gap-2 rounded-lg border bg-muted/30 p-2 text-xs">
          <Loader2 className="h-3 w-3 animate-spin" />
          <span className="text-muted-foreground">
            Prefetching next page...
          </span>
        </div>
      )}
      {prefetchingState.previous && (
        <div className="flex items-center gap-2 rounded-lg border bg-muted/30 p-2 text-xs">
          <Loader2 className="h-3 w-3 animate-spin" />
          <span className="text-muted-foreground">
            Prefetching previous page...
          </span>
        </div>
      )}

      {/* Table components */}
    </div>
  )
}
```

**Key points about prefetching:**

- **State tracking**: Use a ref (`effectRunRef`) to track effect runs and prevent state updates from stale prefetch operations
- **State reset**: Reset prefetching state at the start of each effect run to prevent stuck indicators
- **Error handling**: Always reset state in `.catch()` handlers to prevent stuck indicators on errors
- **Cleanup**: Reset state in the cleanup function when dependencies change

With prefetching enabled, navigation between pages feels instant because the data is already cached. The pagination buttons remain enabled during background fetching, allowing users to navigate to prefetched pages immediately. The prefetching indicators provide visual feedback so users know when background loading is happening.

### Error Handling

TanStack Query provides error states and retry logic:

```tsx showLineNumbers
const { data, error, isError } = useQuery({
  queryKey: ['products', ...],
  queryFn: fetchProducts,
  retry: 1, // Retry failed requests once
})

if (isError) {
  return <ErrorDisplay error={error} />
}
```

## URL State Management with nuqs

This example uses [nuqs](https://nuqs.dev/) to persist all table state in the URL, making table views bookmarkable and shareable. The state includes:

- Pagination (page index and page size)
- Sorting configuration
- Column filters (standard and inline modes)
- Global search/filter
- Column visibility
- Filter mode (standard vs inline)

### URL State Parsers

Define parsers for each state variable:

```tsx showLineNumbers
import { parseAsInteger, parseAsJson, parseAsString } from "nuqs"
import type { SortingState } from "@tanstack/react-table"
import type { ExtendedColumnFilter } from "@/components/niko-data-table/types"

const tableStateParsers = {
  pageIndex: parseAsInteger.withDefault(0),
  pageSize: parseAsInteger.withDefault(10),
  sort: parseAsJson<SortingState>(value => value as SortingState).withDefault(
    [],
  ),
  filters: parseAsJson<ExtendedColumnFilter<Product>[]>(
    value => value as ExtendedColumnFilter<Product>[],
  ).withDefault([]),
  search: parseAsString.withDefault(""),
  globalFilter: parseAsJson<
    string | { filters: unknown[]; joinOperator: string }
  >(value => {
    if (value && typeof value === "object" && "filters" in value) {
      return value as { filters: unknown[]; joinOperator: string }
    }
    if (typeof value === "string") {
      return value
    }
    return ""
  }).withDefault(""),
  columnVisibility: parseAsJson<VisibilityState>(
    value => value as VisibilityState,
  ).withDefault({}),
  inlineFilters: parseAsJson<ExtendedColumnFilter<Product>[]>(
    value => value as ExtendedColumnFilter<Product>[],
  ).withDefault([]),
  filterMode: parseAsString.withDefault("standard"),
}
```

### Using useQueryStates

The `useQueryStates` hook provides URL state management:

```tsx showLineNumbers
import { useQueryStates } from "nuqs"

function ServerSideTable() {
  const [urlParams, setUrlParams] = useQueryStates(tableStateParsers, {
    urlKeys: {
      pageIndex: "page",
      pageSize: "perPage",
      sort: "sort",
      filters: "filters",
      search: "search",
      globalFilter: "global",
      columnVisibility: "cols",
      inlineFilters: "inline",
      filterMode: "mode",
    },
    history: "replace",
    scroll: false,
    shallow: true,
  })

  // Use urlParams for table state
  const pagination = useMemo(
    () => ({
      pageIndex: urlParams.pageIndex,
      pageSize: urlParams.pageSize,
    }),
    [urlParams.pageIndex, urlParams.pageSize],
  )

  // Update URL when state changes
  const handlePaginationChange = useCallback(
    (updater: Updater<PaginationState>) => {
      const newPagination =
        typeof updater === "function" ? updater(pagination) : updater
      void setUrlParams({
        pageIndex: newPagination.pageIndex,
        pageSize: newPagination.pageSize,
      })
    },
    [pagination, setUrlParams],
  )

  // ... rest of component
}
```

## Manual Pagination, Sorting, and Filtering

When using server-side operations, you need to enable manual modes:

```tsx showLineNumbers
<DataTableRoot
  config={{
    manualPagination: true, // Server handles pagination
    manualSorting: true, // Server handles sorting
    manualFiltering: true, // Server handles filtering
    pageCount: totalPages, // Total pages from server
  }}
/>
```

## Query Key Strategy

The query key should include all parameters that affect the data:

```tsx showLineNumbers
const queryKey = [
  "products", // Resource name
  pagination.pageIndex, // Page number
  pagination.pageSize, // Page size
  sorting, // Sort configuration
  globalFilter, // Search query
  columnFilters, // Column filters
]
```

This ensures that:

- Different pages have separate cache entries
- Changing filters invalidates and refetches data
- Browser back/forward navigation uses cached data

## Optimistic Updates

You can use TanStack Query mutations for optimistic updates:

```tsx showLineNumbers
import { useMutation, useQueryClient } from "@tanstack/react-query"

function useUpdateProduct() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: updateProduct,
    onMutate: async newProduct => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ["products"] })

      // Snapshot previous value
      const previousProducts = queryClient.getQueryData(["products"])

      // Optimistically update
      queryClient.setQueryData(["products"], old => ({
        ...old,
        data: old.data.map(p => (p.id === newProduct.id ? newProduct : p)),
      }))

      return { previousProducts }
    },
    onError: (err, newProduct, context) => {
      // Rollback on error
      queryClient.setQueryData(["products"], context.previousProducts)
    },
    onSettled: () => {
      // Refetch after mutation
      queryClient.invalidateQueries({ queryKey: ["products"] })
    },
  })
}
```

## When to Use

**✅ Use Server-Side Table + Nuqs when:**

- Working with large datasets (thousands+ rows)
- Data needs to be fetched from an API
- You want automatic caching and background updates
- You need request deduplication
- You want optimistic updates
- You need error handling and retry logic
- You want URL state persistence for bookmarkable and shareable table views
- You need table state to survive page refreshes

**❌ Consider other options when:**

- Working with small datasets (< 1000 rows) - use client-side filtering
- Data is static or rarely changes - simple state management may suffice
- You don't need URL state persistence - use a simpler server-side implementation without nuqs

## Best Practices

1. **Set appropriate stale times**: Balance freshness with performance
2. **Use query invalidation**: Invalidate queries after mutations
3. **Implement proper error handling**: Show user-friendly error messages
4. **Optimize query keys**: Include all parameters that affect data
5. **Use loading states**: Show skeletons during initial load
6. **Handle pagination**: Reset to page 1 when filters change

## Next Steps

- [Advanced Table](/data-table/advanced-table) - Learn about advanced filtering
- [Advanced Nuqs Table](/data-table/advanced-nuqs-table) - Add URL state persistence
- [TanStack Query Docs](https://tanstack.com/query/latest) - Learn more about TanStack Query
