{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-faceted-filter",
  "title": "DataTable Faceted Filter",
  "description": "Faceted filter for single/multiple selection with option counts and search.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "https://niko-table.com/r/data-table.json",
    "button",
    "badge",
    "command",
    "popover",
    "separator"
  ],
  "files": [
    {
      "path": "src/components/niko-table/components/data-table-faceted-filter.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport type { Table } from \"@tanstack/react-table\"\nimport {\n  TableFacetedFilter,\n  TableFacetedFilterContent,\n  useTableFacetedFilter,\n  type TableFacetedFilterProps,\n} from \"../filters/table-faceted-filter\"\nimport { useDataTable } from \"../core\"\nimport type { Option } from \"../types\"\nimport { useDerivedColumnTitle } from \"../hooks/use-derived-column-title\"\nimport { useGeneratedOptionsForColumn } from \"../hooks/use-generated-options\"\nimport { formatLabel } from \"../lib/format\"\nimport { getFilteredRowsExcludingColumn } from \"../lib/filter-rows\"\n\ntype DataTableFacetedFilterProps<TData, TValue> = Omit<\n  TableFacetedFilterProps<TData, TValue>,\n  \"column\" | \"options\"\n> & {\n  /**\n   * The accessor key of the column to filter (matches column definition)\n   */\n  accessorKey: keyof TData & string\n  /**\n   * Optional title override (if not provided, will use column.meta.label)\n   */\n  title?: string\n  /**\n   * Static options (if provided, will be used instead of dynamic generation)\n   */\n  options?: Option[]\n  /**\n   * Whether to show counts for each option\n   * @default true\n   */\n  showCounts?: boolean\n  /**\n   * Whether to update counts based on other active filters\n   * @default true\n   */\n  dynamicCounts?: boolean\n  /**\n   * If true, only show options that exist in the currently filtered table rows.\n   * If false, show all options from the entire dataset (useful for multi-select filters\n   * where you want to see all possible options even if they're not in the current filtered results).\n   * @default true\n   */\n  limitToFilteredRows?: boolean\n}\n\n/**\n * A faceted filter component that automatically connects to the DataTable context\n * and dynamically generates options with counts based on the filtered data.\n *\n * @example - Auto-detect options from data with dynamic counts\n * const columns: DataTableColumnDef[] = [{ accessorKey: \"category\", ..., meta: { label: \"Category\" } }, ...]\n * <DataTableFacetedFilter accessorKey=\"category\" />\n *\n * @example - With static options\n * const categoryOptions: Option[] = [\n *   { label: \"Electronics\", value: \"electronics\" },\n *   { label: \"Clothing\", value: \"clothing\" },\n * ]\n * <DataTableFacetedFilter\n *   accessorKey=\"category\"\n *   title=\"Category\"\n *   options={categoryOptions}\n * />\n *\n * @example - With dynamic option generation and multiple selection\n * <DataTableFacetedFilter\n *   accessorKey=\"brand\"\n *   title=\"Brand\"\n *   multiple\n *   dynamicCounts\n * />\n *\n * @example - Without counts\n * <DataTableFacetedFilter\n *   accessorKey=\"status\"\n *   showCounts={false}\n * />\n */\n\n/**\n * Hook to generate options for faceted filter.\n * Refactored from DataTableFacetedFilter to be reusable.\n */\nfunction useFacetedOptions<TData>({\n  table,\n  accessorKey,\n  options,\n  showCounts = true,\n  dynamicCounts = true,\n  limitToFilteredRows = true,\n}: {\n  table: Table<TData>\n  accessorKey: string\n  options?: Option[]\n  showCounts?: boolean\n  dynamicCounts?: boolean\n  limitToFilteredRows?: boolean\n}) {\n  const column = table.getColumn(accessorKey)\n\n  // Prefer shared generator that respects column meta (autoOptions, mergeStrategy, dynamicCounts, showCounts)\n  // limitToFilteredRows controls whether to generate options from filtered rows (true) or all rows (false)\n  const generatedFromMeta = useGeneratedOptionsForColumn(table, accessorKey, {\n    showCounts,\n    dynamicCounts,\n    limitToFilteredRows,\n  })\n\n  // Get current filter state for reactivity\n  const state = table.getState()\n  const columnFilters = state.columnFilters\n  const globalFilter = state.globalFilter\n\n  /**\n   * REACTIVITY FIX: Extract coreRows outside memos so that when async data\n   * arrives, the new rows array reference triggers memo recomputation.\n   * Without this, `table` reference is stable across data changes and memos\n   * would return stale (empty) results after initial render with no data.\n   */\n  const coreRows = table.getCoreRowModel().rows\n\n  // Fallback generator that works for any variant (text/boolean/etc.) to preserve\n  // the original behavior of faceted filter for quick categorical filtering.\n  const fallbackGenerated = React.useMemo((): Option[] => {\n    if (!column) return []\n\n    const meta = column.columnDef.meta\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const autoOptionsFormat = (meta as any)?.autoOptionsFormat ?? true\n\n    // limitToFilteredRows controls whether to generate options from filtered rows (true) or all rows (false)\n    // When generating options, we exclude the current column's filter so we see all options\n    // that exist in the filtered dataset (from other filters)\n    const rows = limitToFilteredRows\n      ? getFilteredRowsExcludingColumn(\n          table,\n          coreRows,\n          accessorKey,\n          columnFilters,\n          globalFilter,\n        )\n      : coreRows\n\n    const valueCounts = new Map<string, number>()\n\n    rows.forEach(row => {\n      const raw = row.getValue(accessorKey) as unknown\n      const values: unknown[] = Array.isArray(raw) ? raw : [raw]\n      values.forEach(v => {\n        if (v == null) return\n        const s = String(v)\n        if (!s) return\n        valueCounts.set(s, (valueCounts.get(s) || 0) + 1)\n      })\n    })\n\n    return Array.from(valueCounts.entries())\n      .map(([value, count]) => ({\n        label: autoOptionsFormat ? formatLabel(value) : value,\n        value,\n        count: showCounts ? count : undefined,\n      }))\n      .sort((a, b) => a.label.localeCompare(b.label))\n  }, [\n    accessorKey,\n    column,\n    limitToFilteredRows,\n    showCounts,\n    coreRows,\n    table,\n    columnFilters,\n    globalFilter,\n  ])\n\n  // Final options selection priority: explicit props.options > meta-driven > fallback\n  const dynamicOptions = React.useMemo(() => {\n    // If options are explicitly provided, we still need to respect limitToFilteredRows\n    if (options && options.length > 0) {\n      if (limitToFilteredRows && column) {\n        // Filter options to only include those that exist in the relevant rows\n        // We reuse fallbackGenerated's logic of getting occurrenceMap from rows\n        const rows = getFilteredRowsExcludingColumn(\n          table,\n          coreRows,\n          accessorKey,\n          columnFilters,\n          globalFilter,\n        )\n        const occurrenceMap = new Map<string, boolean>()\n        rows.forEach(row => {\n          const raw = row.getValue(accessorKey) as unknown\n          const values: unknown[] = Array.isArray(raw) ? raw : [raw]\n          values.forEach(v => {\n            if (v != null) occurrenceMap.set(String(v), true)\n          })\n        })\n        return options.filter(opt => occurrenceMap.has(opt.value))\n      }\n      return options\n    }\n\n    return generatedFromMeta.length ? generatedFromMeta : fallbackGenerated\n  }, [\n    options,\n    generatedFromMeta,\n    fallbackGenerated,\n    limitToFilteredRows,\n    column,\n    coreRows,\n    table,\n    accessorKey,\n    columnFilters,\n    globalFilter,\n  ])\n\n  return dynamicOptions\n}\n\nexport function DataTableFacetedFilter<TData, TValue = unknown>({\n  accessorKey,\n  options,\n  showCounts = true,\n  dynamicCounts = true,\n  limitToFilteredRows = true,\n  title,\n  multiple,\n  trigger,\n  ...props\n}: DataTableFacetedFilterProps<TData, TValue>) {\n  const { table } = useDataTable<TData>()\n  const column = table.getColumn(accessorKey as string)\n\n  const derivedTitle = useDerivedColumnTitle(column, String(accessorKey), title)\n\n  const dynamicOptions = useFacetedOptions({\n    table,\n    accessorKey: accessorKey as string,\n    options,\n    showCounts,\n    dynamicCounts,\n    limitToFilteredRows,\n  })\n\n  // Early return if column not found\n  if (!column) {\n    console.warn(\n      `Column with accessorKey \"${accessorKey}\" not found in table columns`,\n    )\n    return null\n  }\n\n  return (\n    <TableFacetedFilter\n      column={column}\n      options={dynamicOptions}\n      title={derivedTitle}\n      multiple={multiple}\n      trigger={trigger}\n      {...props}\n    />\n  )\n}\n\n/**\n * @required displayName is required for auto feature detection\n * @see \"feature-detection.ts\"\n */\n\nDataTableFacetedFilter.displayName = \"DataTableFacetedFilter\"\n\nexport function DataTableFacetedFilterContent<TData, TValue = unknown>({\n  accessorKey,\n  options,\n  showCounts = true,\n  dynamicCounts = true,\n  limitToFilteredRows = true,\n  title,\n  multiple,\n  onValueChange,\n}: DataTableFacetedFilterProps<TData, TValue>) {\n  const { table } = useDataTable<TData>()\n  const column = table.getColumn(accessorKey as string)\n  const derivedTitle = useDerivedColumnTitle(column, String(accessorKey), title)\n\n  const dynamicOptions = useFacetedOptions({\n    table,\n    accessorKey,\n    options,\n    showCounts,\n    dynamicCounts,\n    limitToFilteredRows,\n  })\n\n  // Use the shared hook for filter logic\n  const { selectedValues, onItemSelect, onReset } = useTableFacetedFilter({\n    column,\n    onValueChange,\n    multiple,\n  })\n\n  if (!column) return null\n\n  return (\n    <TableFacetedFilterContent\n      title={derivedTitle}\n      options={dynamicOptions}\n      selectedValues={selectedValues}\n      onItemSelect={onItemSelect}\n      onReset={onReset}\n    />\n  )\n}\n\nDataTableFacetedFilterContent.displayName = \"DataTableFacetedFilterContent\"\n",
      "type": "registry:component",
      "target": "components/niko-table/components/data-table-faceted-filter.tsx"
    },
    {
      "path": "src/components/niko-table/filters/table-faceted-filter.tsx",
      "content": "\"use client\"\n\n/**\n * Table faceted filter component\n * @description A faceted filter component for DataTable that allows users to filter data based on multiple selectable options. It supports both single and multiple selection modes.\n */\n\nimport type { Column } from \"@tanstack/react-table\"\nimport { Check, PlusCircle, XCircle } from \"lucide-react\"\nimport * as React from \"react\"\n\nimport { Badge } from \"@/components/ui/badge\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n  CommandSeparator,\n} from \"@/components/ui/command\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { cn } from \"@/lib/utils\"\nimport type { ExtendedColumnFilter, Option } from \"../types\"\nimport {\n  FILTER_OPERATORS,\n  FILTER_VARIANTS,\n  JOIN_OPERATORS,\n} from \"../lib/constants\"\n\nexport interface TableFacetedFilterProps<TData, TValue> {\n  column?: Column<TData, TValue>\n  title?: string\n  options: Option[]\n  multiple?: boolean\n  /**\n   * Callback fired when filter value changes\n   * Useful for server-side filtering or external state management\n   */\n  onValueChange?: (value: string[] | undefined) => void\n  /**\n   * Optional custom trigger element\n   */\n  trigger?: React.ReactNode\n}\n\nexport function useTableFacetedFilter<TData>({\n  column,\n  onValueChange,\n  multiple,\n}: {\n  column?: Column<TData, unknown>\n  onValueChange?: (value: string[] | undefined) => void\n  multiple?: boolean\n}) {\n  const columnFilterValue = column?.getFilterValue()\n\n  // Handle both ExtendedColumnFilter format (new) and legacy array format\n  const selectedValues = React.useMemo(() => {\n    // Handle ExtendedColumnFilter format (from filter menu or new faceted filter)\n    if (\n      columnFilterValue &&\n      typeof columnFilterValue === \"object\" &&\n      !Array.isArray(columnFilterValue) &&\n      \"value\" in columnFilterValue\n    ) {\n      const filterValue = (columnFilterValue as ExtendedColumnFilter<TData>)\n        .value\n      return new Set(\n        Array.isArray(filterValue) ? filterValue : [String(filterValue)],\n      )\n    }\n    // Handle legacy array format (backward compatibility)\n    return new Set(Array.isArray(columnFilterValue) ? columnFilterValue : [])\n  }, [columnFilterValue])\n\n  const onItemSelect = React.useCallback(\n    (option: Option, isSelected: boolean) => {\n      if (!column) return\n\n      if (multiple) {\n        const newSelectedValues = new Set(selectedValues)\n        if (isSelected) {\n          newSelectedValues.delete(option.value)\n        } else {\n          newSelectedValues.add(option.value)\n        }\n        const filterValues = Array.from(newSelectedValues)\n\n        if (filterValues.length === 0) {\n          column.setFilterValue(undefined)\n          onValueChange?.(undefined)\n        } else {\n          // Create ExtendedColumnFilter format for interoperability with filter menu\n          // FORCE variant to multi_select when using IN operator to ensure it shows up in the menu\n          const extendedFilter: ExtendedColumnFilter<TData> = {\n            id: column.id as Extract<keyof TData, string>,\n            value: filterValues,\n            variant: FILTER_VARIANTS.MULTI_SELECT,\n            operator: FILTER_OPERATORS.IN,\n            filterId: `faceted-${column.id}`,\n            joinOperator: JOIN_OPERATORS.AND,\n          }\n          column.setFilterValue(extendedFilter)\n          onValueChange?.(filterValues)\n        }\n      } else {\n        // Single selection\n        if (isSelected) {\n          column.setFilterValue(undefined)\n          onValueChange?.(undefined)\n        } else {\n          // Create ExtendedColumnFilter format for single selection\n          // Use EQUAL operator for single select\n          const extendedFilter: ExtendedColumnFilter<TData> = {\n            id: column.id as Extract<keyof TData, string>,\n            value: option.value, // Single value, not array\n            variant: FILTER_VARIANTS.SELECT,\n            operator: FILTER_OPERATORS.EQ,\n            filterId: `faceted-${column.id}`,\n            joinOperator: JOIN_OPERATORS.AND,\n          }\n          column.setFilterValue(extendedFilter)\n          onValueChange?.([option.value])\n        }\n      }\n    },\n    [column, multiple, selectedValues, onValueChange],\n  )\n\n  const onReset = React.useCallback(\n    (event?: React.MouseEvent) => {\n      event?.stopPropagation()\n      column?.setFilterValue(undefined)\n      onValueChange?.(undefined)\n    },\n    [column, onValueChange],\n  )\n\n  return {\n    selectedValues,\n    onItemSelect,\n    onReset,\n  }\n}\n\nexport function TableFacetedFilter<TData, TValue>({\n  column,\n  title,\n  options = [],\n  multiple,\n  onValueChange,\n  trigger,\n}: TableFacetedFilterProps<TData, TValue>) {\n  const [open, setOpen] = React.useState(false)\n\n  const { selectedValues, onItemSelect, onReset } = useTableFacetedFilter({\n    column,\n    onValueChange,\n    multiple,\n  })\n\n  // Wrap onItemSelect to close multiple=false popover\n  const handleItemSelect = React.useCallback(\n    (option: Option, isSelected: boolean) => {\n      onItemSelect(option, isSelected)\n      if (!multiple) {\n        setOpen(false)\n      }\n    },\n    [onItemSelect, multiple, setOpen],\n  )\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        {trigger || (\n          <Button variant=\"outline\" size=\"sm\" className=\"h-8 border-dashed\">\n            {selectedValues?.size > 0 ? (\n              <div\n                role=\"button\"\n                aria-label={`Clear ${title} filter`}\n                tabIndex={0}\n                onClick={onReset}\n                onKeyDown={e => {\n                  if (e.key === \"Enter\" || e.key === \" \") {\n                    e.preventDefault()\n                    onReset(e as unknown as React.MouseEvent)\n                  }\n                }}\n                className=\"rounded-sm opacity-70 transition-opacity hover:opacity-100 focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none\"\n              >\n                <XCircle className=\"size-4\" />\n              </div>\n            ) : (\n              <PlusCircle className=\"size-4\" />\n            )}\n            {title}\n            {selectedValues?.size > 0 && (\n              <>\n                <Separator orientation=\"vertical\" className=\"mx-2 h-4\" />\n                <Badge\n                  variant=\"secondary\"\n                  className=\"rounded-sm px-1 font-normal lg:hidden\"\n                >\n                  {selectedValues.size}\n                </Badge>\n                <div className=\"hidden items-center gap-1 lg:flex\">\n                  {selectedValues.size > 2 ? (\n                    <Badge\n                      variant=\"secondary\"\n                      className=\"rounded-sm px-1 font-normal\"\n                    >\n                      {selectedValues.size} selected\n                    </Badge>\n                  ) : (\n                    options\n                      .filter(option => selectedValues.has(option.value))\n                      .map(option => (\n                        <Badge\n                          variant=\"secondary\"\n                          key={option.value}\n                          className=\"rounded-sm px-1 font-normal\"\n                        >\n                          {option.label}\n                        </Badge>\n                      ))\n                  )}\n                </div>\n              </>\n            )}\n          </Button>\n        )}\n      </PopoverTrigger>\n      <PopoverContent className=\"w-52 p-0\" align=\"start\">\n        <TableFacetedFilterContent\n          title={title}\n          options={options}\n          selectedValues={selectedValues}\n          onItemSelect={handleItemSelect}\n          onReset={onReset}\n        />\n      </PopoverContent>\n    </Popover>\n  )\n}\n\nexport function TableFacetedFilterContent({\n  title,\n  options,\n  selectedValues,\n  onItemSelect,\n  onReset,\n}: {\n  title?: string\n  options: Option[]\n  selectedValues: Set<string>\n  onItemSelect: (option: Option, isSelected: boolean) => void\n  onReset: (event?: React.MouseEvent) => void\n}) {\n  return (\n    <Command>\n      <CommandInput placeholder={title} className=\"pl-2\" />\n      <CommandList className=\"max-h-full\">\n        <CommandEmpty>No results found.</CommandEmpty>\n        <CommandGroup className=\"max-h-75 overflow-x-hidden overflow-y-auto\">\n          {options.map(option => {\n            const isSelected = selectedValues.has(option.value)\n\n            return (\n              <CommandItem\n                key={option.value}\n                onSelect={() => onItemSelect(option, isSelected)}\n              >\n                <div\n                  className={cn(\n                    \"mr-2 flex size-4 items-center justify-center rounded-sm border border-primary\",\n                    isSelected\n                      ? \"bg-primary text-primary-foreground\"\n                      : \"opacity-50 [&_svg]:invisible\",\n                  )}\n                >\n                  <Check className=\"size-4\" />\n                </div>\n                {option.icon && <option.icon className=\"mr-2 size-4\" />}\n                <span className=\"truncate\">{option.label}</span>\n                {option.count !== undefined && (\n                  <span className=\"ml-auto font-mono text-xs\">\n                    {option.count}\n                  </span>\n                )}\n              </CommandItem>\n            )\n          })}\n        </CommandGroup>\n        {selectedValues.size > 0 && (\n          <>\n            <CommandSeparator />\n            <CommandGroup>\n              <CommandItem\n                onSelect={() => onReset()}\n                className=\"justify-center text-center\"\n              >\n                Clear filters\n              </CommandItem>\n            </CommandGroup>\n          </>\n        )}\n      </CommandList>\n    </Command>\n  )\n}\n\n/**\n * @required displayName is required for auto feature detection\n * @see \"feature-detection.ts\"\n */\n\nTableFacetedFilter.displayName = \"TableFacetedFilter\"\n",
      "type": "registry:component",
      "target": "components/niko-table/filters/table-faceted-filter.tsx"
    }
  ],
  "type": "registry:component"
}