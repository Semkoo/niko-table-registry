{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-inline-filter",
  "title": "DataTable Inline Filter",
  "description": "Inline filter toolbar that displays active filters as editable chips.",
  "dependencies": [
    "lucide-react",
    "react-day-picker"
  ],
  "registryDependencies": [
    "https://niko-table.com/r/data-table.json",
    "button",
    "input",
    "popover",
    "command",
    "select",
    "calendar"
  ],
  "files": [
    {
      "path": "src/components/niko-table/components/data-table-inline-filter.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\nimport { useDataTable } from \"../core\"\nimport {\n  TableInline,\n  type TableInlineProps,\n} from \"../filters/table-inline-filter\"\nimport { useGeneratedOptions } from \"../hooks/use-generated-options\"\nimport { FILTER_VARIANTS } from \"../lib/constants\"\nimport type { Option } from \"../types\"\n\ntype BaseInlineProps<TData> = Omit<TableInlineProps<TData>, \"table\">\n\ninterface AutoOptionProps {\n  autoOptions?: boolean\n  showCounts?: boolean\n  dynamicCounts?: boolean\n  /**\n   * If true, only generate options from filtered rows. If false, generate from all rows.\n   * This controls which rows are used to generate the option list itself.\n   * Note: This is separate from dynamicCounts which controls count calculation.\n   * @default true\n   */\n  limitToFilteredRows?: boolean\n  includeColumns?: string[]\n  excludeColumns?: string[]\n  limitPerColumn?: number\n  mergeStrategy?: \"preserve\" | \"augment\" | \"replace\"\n}\n\ntype DataTableInlineFilterProps<TData> = BaseInlineProps<TData> &\n  AutoOptionProps\n\nexport function DataTableInlineFilter<TData>({\n  autoOptions = true,\n  showCounts = true,\n  dynamicCounts = true,\n  limitToFilteredRows = true,\n  includeColumns,\n  excludeColumns,\n  limitPerColumn,\n  mergeStrategy = \"preserve\",\n  ...props\n}: DataTableInlineFilterProps<TData>) {\n  const { table } = useDataTable<TData>()\n\n  const generatedOptions = useGeneratedOptions(table, {\n    showCounts,\n    dynamicCounts,\n    limitToFilteredRows,\n    includeColumns,\n    excludeColumns,\n    limitPerColumn,\n  })\n\n  // Mutate meta.options for select/multi-select columns similar to menu wrapper\n  // This keeps TableInline copy-paste friendly without extra props.\n  // Memo to avoid repeated mutation on every render.\n  React.useMemo(() => {\n    if (!autoOptions) return null\n    table.getAllColumns().forEach(column => {\n      const meta = (column.columnDef.meta ||= {})\n      const variant = meta.variant ?? FILTER_VARIANTS.TEXT\n      if (\n        variant !== FILTER_VARIANTS.SELECT &&\n        variant !== FILTER_VARIANTS.MULTI_SELECT\n      )\n        return\n      const gen = generatedOptions[column.id]\n      if (!gen || gen.length === 0) return\n\n      if (!meta.options) {\n        meta.options = gen\n        return\n      }\n\n      if (mergeStrategy === \"replace\") {\n        meta.options = gen\n        return\n      }\n\n      if (mergeStrategy === \"augment\") {\n        const countMap = new Map(gen.map(o => [o.value, o.count]))\n        meta.options = meta.options.map((opt: Option) => ({\n          ...opt,\n          count: showCounts\n            ? (countMap.get(opt.value) ?? opt.count)\n            : undefined,\n        }))\n      }\n    })\n  }, [autoOptions, generatedOptions, mergeStrategy, showCounts, table])\n\n  return <TableInline table={table} {...props} />\n}\n\n/**\n * @required displayName is required for auto feature detection\n * @see \"feature-detection.ts\"\n */\n\nDataTableInlineFilter.displayName = \"DataTableInlineFilter\"\n",
      "type": "registry:component",
      "target": "components/niko-table/components/data-table-inline-filter.tsx"
    },
    {
      "path": "src/components/niko-table/filters/table-inline-filter.tsx",
      "content": "\"use client\"\n\n/**\n * Table inline filter component\n * @description An inline filter component for DataTable that allows users to filter data with operator selection and multiple filter types.\n *\n * @architecture\n * This file is organized into sections for easy copy-paste:\n *\n * 1. **Utilities** (createFilterId) - Helper functions\n *\n * 2. **Custom Hooks** - Replace useEffect with composable logic:\n *    - useInitialFilters: Extracts initial state from table (replaces initialization useEffect)\n *    - useSyncFiltersWithTable: Syncs filters to table state (replaces sync useEffect)\n *\n * 3. **Filter Value Components** - Inline filter input renderers:\n *    - FilterValueSelector: Command menu for selecting filter values\n *    - Inline filter input renderer (text, number, boolean, select, date)\n *\n * 4. **Main Components**:\n *    - TableInlineFilterItem: Single inline filter badge with controls\n *    - TableInline: Main inline filter toolbar\n *\n * @debugging\n * - All components have displayName for React DevTools\n * - Development-only console.log statements in hooks (NODE_ENV check)\n * - Check table.getState() to see current filter state\n * - Use React DevTools Components tab to inspect component tree\n * - Filter data flow: User Input → onFilterUpdate → filters state → useSyncFiltersWithTable → table state\n */\n\nimport type { Column, Table } from \"@tanstack/react-table\"\nimport {\n  BadgeCheck,\n  CalendarIcon,\n  Check,\n  ListFilter,\n  Text,\n  X,\n} from \"lucide-react\"\nimport * as React from \"react\"\n\nimport { Button } from \"@/components/ui/button\"\nimport { Calendar } from \"@/components/ui/calendar\"\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\"\nimport { Input } from \"@/components/ui/input\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\"\nimport {\n  getDefaultFilterOperator,\n  getFilterOperators,\n  processFiltersForLogic,\n} from \"../lib/data-table\"\nimport { formatDate } from \"../lib/format\"\nimport { useKeyboardShortcut } from \"../hooks\"\nimport { cn } from \"@/lib/utils\"\nimport {\n  FILTER_OPERATORS,\n  FILTER_VARIANTS,\n  JOIN_OPERATORS,\n  KEYBOARD_SHORTCUTS,\n} from \"../lib/constants\"\nimport { dataTableConfig } from \"../config/data-table\"\nimport type {\n  ExtendedColumnFilter,\n  FilterOperator,\n  JoinOperator,\n  Option,\n} from \"../types\"\nimport { TableRangeFilter } from \"./table-range-filter\"\n\n/* --------------------------------- Utilities -------------------------------- */\n\n/**\n * Create a deterministic filter ID based on filter properties\n * This ensures filters can be shared via URL and will have consistent IDs\n */\nfunction createFilterId<TData>(\n  filter: Omit<ExtendedColumnFilter<TData>, \"filterId\">,\n  index?: number,\n): string {\n  // Create a deterministic ID based on filter properties\n  // Using a combination that should be unique for each filter configuration\n  const valueStr =\n    typeof filter.value === \"string\"\n      ? filter.value\n      : JSON.stringify(filter.value)\n\n  // Include index as a fallback to ensure uniqueness for URL sharing\n  const indexSuffix = typeof index === FILTER_VARIANTS.NUMBER ? `-${index}` : \"\"\n\n  return `${filter.id}-${filter.operator}-${filter.variant}-${valueStr}${indexSuffix}`\n    .toLowerCase()\n    .replace(/[^a-z0-9-]/g, \"-\")\n    .replace(/-+/g, \"-\")\n    .substring(0, 100) // Limit length to avoid extremely long IDs\n}\n\n/**\n * Type for filters without filterId (for URL serialization)\n */\ntype FilterWithoutId<TData> = Omit<ExtendedColumnFilter<TData>, \"filterId\">\n\n/**\n * Normalize filters loaded from URL by ensuring they have filterId\n * If filterId is missing, generate it deterministically\n *\n * This allows filters to be stored in URL without filterId, making URLs shorter\n * and more robust. The filterId is auto-generated when filters are loaded.\n *\n * @param filters - Filters that may or may not have filterId\n * @returns Filters with guaranteed filterId values\n */\nfunction normalizeFiltersFromUrl<TData>(\n  filters: (FilterWithoutId<TData> | ExtendedColumnFilter<TData>)[],\n): ExtendedColumnFilter<TData>[] {\n  return filters.map((filter, index) => {\n    // If filterId is missing, generate it\n    if (!(\"filterId\" in filter) || !filter.filterId) {\n      return {\n        ...filter,\n        filterId: createFilterId(filter, index),\n      } as ExtendedColumnFilter<TData>\n    }\n    return filter as ExtendedColumnFilter<TData>\n  })\n}\n\n/* -------------------------------- Custom Hooks ------------------------------ */\n\n/**\n * Hook to initialize filters from table state (for URL restoration)\n * Replaces the initialization useEffect with derived state\n *\n * @description This hook runs ONCE on mount to extract initial filter state from:\n * 1. Controlled filters (if provided via props)\n * 2. Table's globalFilter (for OR logic filters)\n * 3. Table's columnFilters (for AND logic filters)\n *\n * @debug Check React DevTools > Components > useInitialFilters to see returned value\n */\nfunction useInitialFilters<TData>(\n  table: Table<TData>,\n  controlledFilters?: ExtendedColumnFilter<TData>[],\n): ExtendedColumnFilter<TData>[] {\n  const initialFilters = React.useMemo(() => {\n    if (controlledFilters) {\n      const normalized = normalizeFiltersFromUrl(controlledFilters)\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(\n          \"[TableInline useInitialFilters] Using controlled filters:\",\n          normalized,\n        )\n      }\n      return normalized\n    }\n\n    const globalFilter = table.getState().globalFilter\n    if (\n      globalFilter &&\n      typeof globalFilter === \"object\" &&\n      \"filters\" in globalFilter\n    ) {\n      const filterObj = globalFilter as {\n        filters: (FilterWithoutId<TData> | ExtendedColumnFilter<TData>)[]\n      }\n      const normalized = normalizeFiltersFromUrl(filterObj.filters)\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(\n          \"[TableInline useInitialFilters] Extracted from globalFilter:\",\n          normalized,\n        )\n      }\n      return normalized\n    }\n\n    const columnFilters = table.getState().columnFilters\n    if (columnFilters && columnFilters.length > 0) {\n      const extractedFilters = columnFilters\n        .map(cf => cf.value)\n        .filter(\n          (v): v is FilterWithoutId<TData> | ExtendedColumnFilter<TData> =>\n            v !== null && typeof v === \"object\" && \"id\" in v,\n        )\n      if (extractedFilters.length > 0) {\n        const normalized = normalizeFiltersFromUrl(extractedFilters)\n        if (process.env.NODE_ENV === \"development\") {\n          console.log(\n            \"[TableInline useInitialFilters] Extracted from columnFilters:\",\n            normalized,\n          )\n        }\n        return normalized\n      }\n    }\n\n    if (process.env.NODE_ENV === \"development\") {\n      console.log(\"[TableInline useInitialFilters] No initial filters found\")\n    }\n    return []\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n\n  return initialFilters\n}\n\n/**\n * Hook to sync filters with table state\n * Replaces multiple useEffect hooks with a single focused effect\n *\n * @description Manages synchronization between filter state and TanStack Table:\n * - Updates table.meta.joinOperator for the global filter function\n * - In uncontrolled mode: updates table's globalFilter or columnFilters based on join operators\n * - In controlled mode: only updates table.meta (parent handles table state)\n *\n * @debug\n * - Check table.getState().globalFilter to see OR filters\n * - Check table.getState().columnFilters to see AND filters\n * - Check table.options.meta.joinOperator to see current join logic\n */\nfunction useSyncFiltersWithTable<TData>(\n  table: Table<TData>,\n  filters: ExtendedColumnFilter<TData>[],\n  isControlled: boolean,\n) {\n  // Use core utility to process filters and determine logic\n  const filterLogic = React.useMemo(\n    () => processFiltersForLogic(filters),\n    [filters],\n  )\n\n  // Update table meta (happens during render, safe mutation)\n  if (table.options.meta) {\n    // eslint-disable-next-line react-hooks/immutability\n    table.options.meta.hasIndividualJoinOperators = true\n    // eslint-disable-next-line react-hooks/immutability\n    table.options.meta.joinOperator = filterLogic.joinOperator\n  }\n\n  // Sync with table state only when filters change (and not in controlled mode)\n  React.useEffect(() => {\n    if (isControlled) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(\n          \"[TableInline useSyncFiltersWithTable] Controlled mode - skipping table sync\",\n        )\n      }\n      return\n    }\n\n    if (process.env.NODE_ENV === \"development\") {\n      console.log(\"[TableInline useSyncFiltersWithTable] Syncing filters:\", {\n        filterCount: filters.length,\n        hasOrFilters: filterLogic.hasOrFilters,\n        hasSameColumnFilters: filterLogic.hasSameColumnFilters,\n        joinOperator: filterLogic.joinOperator,\n      })\n    }\n\n    // Use core utility to determine routing\n    if (filterLogic.shouldUseGlobalFilter) {\n      table.resetColumnFilters()\n\n      table.setGlobalFilter({\n        filters: filterLogic.processedFilters,\n        joinOperator: filterLogic.joinOperator,\n      })\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(\n          \"[TableInline useSyncFiltersWithTable] Set globalFilter (OR/MIXED logic)\",\n          {\n            hasOrFilters: filterLogic.hasOrFilters,\n            hasSameColumnFilters: filterLogic.hasSameColumnFilters,\n          },\n        )\n      }\n    } else {\n      table.setGlobalFilter(\"\")\n      const columnFilters = filterLogic.processedFilters.map(filter => ({\n        id: filter.id,\n        value: {\n          operator: filter.operator,\n          value: filter.value,\n          id: filter.id,\n          filterId: filter.filterId,\n          joinOperator: filter.joinOperator,\n        },\n      }))\n      table.setColumnFilters(columnFilters)\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(\n          \"[TableInline useSyncFiltersWithTable] Set columnFilters (AND logic)\",\n        )\n      }\n    }\n  }, [filters, filterLogic, table, isControlled])\n}\n\nexport interface TableInlineProps<TData> extends React.ComponentProps<\"div\"> {\n  table: Table<TData>\n  filters?: ExtendedColumnFilter<TData>[]\n  onFiltersChange?: (filters: ExtendedColumnFilter<TData>[]) => void\n}\n\nexport function TableInline<TData>({\n  table,\n  filters: controlledFilters,\n  onFiltersChange: controlledOnFiltersChange,\n  children,\n  className,\n  ...props\n}: TableInlineProps<TData>) {\n  const id = React.useId()\n\n  // Check if we're in controlled mode\n  const isControlled = controlledFilters !== undefined\n\n  // Get initial filters from table state (for URL restoration)\n  const initialFilters = useInitialFilters(table, controlledFilters)\n\n  // Internal state - manages filters when not controlled\n  const [internalFilters, setInternalFilters] =\n    React.useState<ExtendedColumnFilter<TData>[]>(initialFilters)\n\n  // Use controlled values if provided, otherwise use internal state\n  const filters = controlledFilters ?? internalFilters\n\n  // Sync filters with table state (handles both controlled and uncontrolled)\n  useSyncFiltersWithTable(table, filters, isControlled)\n\n  // Handler that works with both controlled and internal state\n  const onFiltersChange = React.useCallback(\n    (newFilters: ExtendedColumnFilter<TData>[]) => {\n      if (controlledOnFiltersChange) {\n        // In controlled mode, just notify parent - don't call table methods\n        // Parent will update URL state, which will flow back to table state via DataTableRoot\n        controlledOnFiltersChange(newFilters)\n      } else {\n        // In uncontrolled mode, update internal state\n        // Table sync happens via useSyncFiltersWithTable hook\n        setInternalFilters(newFilters)\n      }\n    },\n    [controlledOnFiltersChange],\n  )\n\n  const columns = React.useMemo(\n    () => table.getAllColumns().filter(column => column.getCanFilter()),\n    [table],\n  )\n\n  const [open, setOpen] = React.useState(false)\n  const [selectedColumn, setSelectedColumn] =\n    React.useState<Column<TData> | null>(null)\n  const [inputValue, setInputValue] = React.useState(\"\")\n  const triggerRef = React.useRef<HTMLButtonElement>(null)\n  const inputRef = React.useRef<HTMLInputElement>(null)\n\n  const onOpenChange = React.useCallback((open: boolean) => {\n    setOpen(open)\n\n    if (!open) {\n      setTimeout(() => {\n        setSelectedColumn(null)\n        setInputValue(\"\")\n      }, 100)\n    }\n  }, [])\n\n  const onFilterAdd = React.useCallback(\n    (column: Column<TData>, value: string) => {\n      if (\n        !value.trim() &&\n        column.columnDef.meta?.variant !== FILTER_VARIANTS.BOOLEAN\n      ) {\n        return\n      }\n\n      const filterValue =\n        column.columnDef.meta?.variant === FILTER_VARIANTS.MULTI_SELECT\n          ? [value]\n          : value\n\n      const filterWithoutId = {\n        id: column.id as Extract<keyof TData, string>,\n        value: filterValue,\n        variant: column.columnDef.meta?.variant ?? FILTER_VARIANTS.TEXT,\n        operator: getDefaultFilterOperator(\n          column.columnDef.meta?.variant ?? FILTER_VARIANTS.TEXT,\n        ),\n        joinOperator: JOIN_OPERATORS.AND, // Default to AND for new filters\n      }\n\n      // Use current filter length as index to ensure unique IDs\n      const newFilterIndex = filters.length\n\n      const newFilter: ExtendedColumnFilter<TData> = {\n        ...filterWithoutId,\n        filterId: createFilterId(filterWithoutId, newFilterIndex),\n      }\n\n      onFiltersChange([...filters, newFilter])\n      setOpen(false)\n\n      setTimeout(() => {\n        setSelectedColumn(null)\n        setInputValue(\"\")\n      }, 100)\n    },\n    [filters, onFiltersChange],\n  )\n\n  const onFilterRemove = React.useCallback(\n    (filterId: string) => {\n      const updatedFilters = filters.filter(\n        filter => filter.filterId !== filterId,\n      )\n      onFiltersChange(updatedFilters)\n      requestAnimationFrame(() => {\n        triggerRef.current?.focus()\n      })\n    },\n    [filters, onFiltersChange],\n  )\n\n  const onFilterUpdate = React.useCallback(\n    (\n      filterId: string,\n      updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\n    ) => {\n      const updatedFilters = filters.map(filter => {\n        if (filter.filterId === filterId) {\n          return { ...filter, ...updates } as ExtendedColumnFilter<TData>\n        }\n        return filter\n      })\n      onFiltersChange(updatedFilters)\n    },\n    [filters, onFiltersChange],\n  )\n\n  const onFiltersReset = React.useCallback(() => {\n    onFiltersChange([])\n  }, [onFiltersChange])\n\n  // Toggle filter menu with 'F' key\n  useKeyboardShortcut({\n    key: KEYBOARD_SHORTCUTS.FILTER_TOGGLE,\n    onTrigger: () => setOpen(prev => !prev),\n  })\n\n  // Remove last filter with Shift+F\n  useKeyboardShortcut({\n    key: KEYBOARD_SHORTCUTS.FILTER_REMOVE,\n    requireShift: true,\n    onTrigger: () => {\n      if (filters.length > 0) {\n        onFilterRemove(filters[filters.length - 1]?.filterId ?? \"\")\n      }\n    },\n    condition: () => filters.length > 0,\n  })\n\n  const onInputKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLInputElement>) => {\n      const key = event.key.toLowerCase()\n      if (\n        (key === KEYBOARD_SHORTCUTS.BACKSPACE ||\n          key === KEYBOARD_SHORTCUTS.DELETE) &&\n        !inputValue &&\n        selectedColumn\n      ) {\n        event.preventDefault()\n        setSelectedColumn(null)\n      }\n    },\n    [inputValue, selectedColumn],\n  )\n\n  const onTriggerKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLButtonElement>) => {\n      const key = event.key.toLowerCase()\n      if (\n        (key === KEYBOARD_SHORTCUTS.BACKSPACE ||\n          key === KEYBOARD_SHORTCUTS.DELETE) &&\n        filters.length > 0\n      ) {\n        event.preventDefault()\n        onFilterRemove(filters[filters.length - 1]?.filterId ?? \"\")\n      }\n    },\n    [filters, onFilterRemove],\n  )\n\n  return (\n    <div\n      role=\"toolbar\"\n      aria-orientation=\"horizontal\"\n      className={cn(\n        \"flex w-full items-start justify-between gap-2 p-1\",\n        className,\n      )}\n      {...props}\n    >\n      <div className=\"flex flex-1 flex-wrap items-center gap-2\">\n        {filters.map((filter, index) => (\n          <React.Fragment key={filter.filterId}>\n            {/* Show join operator selector before filter (except for first filter) */}\n            {index > 0 && (\n              <Select\n                value={filter.joinOperator || JOIN_OPERATORS.AND}\n                onValueChange={(value: JoinOperator) =>\n                  onFilterUpdate(filter.filterId, { joinOperator: value })\n                }\n              >\n                <SelectTrigger\n                  size=\"sm\"\n                  className=\"w-20 text-xs font-medium uppercase\"\n                >\n                  <SelectValue placeholder={filter.joinOperator || \"and\"} />\n                </SelectTrigger>\n                <SelectContent>\n                  {dataTableConfig.joinOperators.map(operator => (\n                    <SelectItem\n                      key={operator}\n                      value={operator}\n                      className=\"uppercase\"\n                    >\n                      {operator}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            )}\n            <TableInlineFilterItem\n              filter={filter}\n              filterItemId={`${id}-filter-${filter.filterId}`}\n              columns={columns}\n              onFilterUpdate={onFilterUpdate}\n              onFilterRemove={onFilterRemove}\n            />\n          </React.Fragment>\n        ))}\n        {filters.length > 0 && (\n          <Button\n            aria-label=\"Clear all filters\"\n            title=\"Clear all filters\"\n            variant=\"outline\"\n            size=\"icon\"\n            className=\"size-8\"\n            onClick={onFiltersReset}\n          >\n            <X />\n          </Button>\n        )}\n        <Popover open={open} onOpenChange={onOpenChange}>\n          <PopoverTrigger asChild>\n            <Button\n              aria-label=\"Open filter command menu\"\n              title=\"Add filter (Press F)\"\n              variant=\"outline\"\n              size=\"sm\"\n              ref={triggerRef}\n              onKeyDown={onTriggerKeyDown}\n            >\n              <ListFilter />\n              Add filter\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent\n            align=\"start\"\n            className=\"w-full max-w-(--radix-popover-content-available-width) origin-(--radix-popover-content-transform-origin) p-0\"\n          >\n            <Command loop className=\"[&_[cmdk-input-wrapper]_svg]:hidden\">\n              <CommandInput\n                ref={inputRef}\n                placeholder={\n                  selectedColumn\n                    ? (selectedColumn.columnDef.meta?.label ??\n                      selectedColumn.id)\n                    : \"Search fields...\"\n                }\n                value={inputValue}\n                onValueChange={setInputValue}\n                onKeyDown={onInputKeyDown}\n              />\n              <CommandList>\n                {selectedColumn ? (\n                  <>\n                    {selectedColumn.columnDef.meta?.options && (\n                      <CommandEmpty>No options found.</CommandEmpty>\n                    )}\n                    <FilterValueSelector\n                      column={selectedColumn}\n                      value={inputValue}\n                      onSelect={value => onFilterAdd(selectedColumn, value)}\n                    />\n                  </>\n                ) : (\n                  <>\n                    <CommandEmpty>No fields found.</CommandEmpty>\n                    <CommandGroup>\n                      {columns.map(column => (\n                        <CommandItem\n                          key={column.id}\n                          value={column.id}\n                          onSelect={() => {\n                            setSelectedColumn(column)\n                            setInputValue(\"\")\n                            requestAnimationFrame(() => {\n                              inputRef.current?.focus()\n                            })\n                          }}\n                        >\n                          {column.columnDef.meta?.icon && (\n                            <column.columnDef.meta.icon />\n                          )}\n                          <span className=\"truncate\">\n                            {column.columnDef.meta?.label ?? column.id}\n                          </span>\n                        </CommandItem>\n                      ))}\n                    </CommandGroup>\n                  </>\n                )}\n              </CommandList>\n            </Command>\n          </PopoverContent>\n        </Popover>\n      </div>\n      <div className=\"flex items-center gap-2\">{children}</div>\n    </div>\n  )\n}\nTableInline.displayName = \"TableInline\"\n\ninterface TableInlineFilterItemProps<TData> {\n  filter: ExtendedColumnFilter<TData>\n  filterItemId: string\n  columns: Column<TData>[]\n  onFilterUpdate: (\n    filterId: string,\n    updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\n  ) => void\n  onFilterRemove: (filterId: string) => void\n}\n\nfunction TableInlineFilterItem<TData>({\n  filter,\n  filterItemId,\n  columns,\n  onFilterUpdate,\n  onFilterRemove,\n}: TableInlineFilterItemProps<TData>) {\n  const [showFieldSelector, setShowFieldSelector] = React.useState(false)\n  const [showOperatorSelector, setShowOperatorSelector] = React.useState(false)\n  const [showValueSelector, setShowValueSelector] = React.useState(false)\n\n  const column = columns.find(column => column.id === filter.id)\n\n  const operatorListboxId = `${filterItemId}-operator-listbox`\n  const inputId = `${filterItemId}-input`\n\n  const columnMeta = column?.columnDef.meta\n  const filterOperators = getFilterOperators(filter.variant)\n\n  const onItemKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (\n        event.target instanceof HTMLInputElement ||\n        event.target instanceof HTMLTextAreaElement\n      ) {\n        return\n      }\n\n      if (showFieldSelector || showOperatorSelector || showValueSelector) {\n        return\n      }\n\n      const key = event.key.toLowerCase()\n      if (\n        key === KEYBOARD_SHORTCUTS.BACKSPACE ||\n        key === KEYBOARD_SHORTCUTS.DELETE\n      ) {\n        event.preventDefault()\n        onFilterRemove(filter.filterId)\n      }\n    },\n    [\n      filter.filterId,\n      showFieldSelector,\n      showOperatorSelector,\n      showValueSelector,\n      onFilterRemove,\n    ],\n  )\n\n  if (!column) return null\n\n  return (\n    <div\n      key={filter.filterId}\n      role=\"listitem\"\n      id={filterItemId}\n      className=\"flex h-8 items-center rounded-md bg-background\"\n      onKeyDown={onItemKeyDown}\n    >\n      <Popover open={showFieldSelector} onOpenChange={setShowFieldSelector}>\n        <PopoverTrigger asChild>\n          <Button\n            title=\"Change field\"\n            variant=\"ghost\"\n            size=\"sm\"\n            className=\"rounded-none rounded-l-md border border-r-0 font-normal dark:bg-input/30\"\n          >\n            {columnMeta?.icon && (\n              <columnMeta.icon className=\"text-muted-foreground\" />\n            )}\n            {columnMeta?.label ?? column.id}\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent\n          align=\"start\"\n          className=\"w-48 origin-(--radix-popover-content-transform-origin) p-0\"\n        >\n          <Command loop>\n            <CommandInput placeholder=\"Search fields...\" />\n            <CommandList>\n              <CommandEmpty>No fields found.</CommandEmpty>\n              <CommandGroup>\n                {columns.map(column => (\n                  <CommandItem\n                    key={column.id}\n                    value={column.id}\n                    onSelect={() => {\n                      onFilterUpdate(filter.filterId, {\n                        id: column.id as Extract<keyof TData, string>,\n                        variant:\n                          column.columnDef.meta?.variant ??\n                          FILTER_VARIANTS.TEXT,\n                        operator: getDefaultFilterOperator(\n                          column.columnDef.meta?.variant ??\n                            FILTER_VARIANTS.TEXT,\n                        ),\n                        value: \"\",\n                      })\n\n                      setShowFieldSelector(false)\n                    }}\n                  >\n                    {column.columnDef.meta?.icon && (\n                      <column.columnDef.meta.icon />\n                    )}\n                    <span className=\"truncate\">\n                      {column.columnDef.meta?.label ?? column.id}\n                    </span>\n                    <Check\n                      className={cn(\n                        \"ml-auto\",\n                        column.id === filter.id ? \"opacity-100\" : \"opacity-0\",\n                      )}\n                    />\n                  </CommandItem>\n                ))}\n              </CommandGroup>\n            </CommandList>\n          </Command>\n        </PopoverContent>\n      </Popover>\n      <Select\n        open={showOperatorSelector}\n        onOpenChange={setShowOperatorSelector}\n        value={filter.operator}\n        onValueChange={(value: FilterOperator) =>\n          onFilterUpdate(filter.filterId, {\n            operator: value,\n            value:\n              value === FILTER_OPERATORS.EMPTY ||\n              value === FILTER_OPERATORS.NOT_EMPTY\n                ? \"\"\n                : filter.value,\n          })\n        }\n      >\n        <SelectTrigger\n          title=\"Change operator\"\n          aria-controls={operatorListboxId}\n          size=\"sm\"\n          className=\"rounded-none border-r-0 px-2.5 lowercase [&_svg]:hidden\"\n        >\n          <SelectValue placeholder={filter.operator} />\n        </SelectTrigger>\n        <SelectContent\n          id={operatorListboxId}\n          className=\"origin-(--radix-select-content-transform-origin)\"\n        >\n          {filterOperators.map(operator => (\n            <SelectItem\n              key={operator.value}\n              className=\"lowercase\"\n              value={operator.value}\n            >\n              {operator.label}\n            </SelectItem>\n          ))}\n        </SelectContent>\n      </Select>\n      {onFilterInputRender({\n        filter,\n        column,\n        inputId,\n        onFilterUpdate,\n        showValueSelector,\n        setShowValueSelector,\n      })}\n      <Button\n        aria-controls={filterItemId}\n        title={`Remove ${columnMeta?.label ?? column.id} filter`}\n        variant=\"ghost\"\n        size=\"sm\"\n        className=\"h-full rounded-none rounded-r-md border border-l-0 px-1.5 font-normal dark:bg-input/30\"\n        onClick={() => onFilterRemove(filter.filterId)}\n      >\n        <X className=\"size-3.5\" />\n      </Button>\n    </div>\n  )\n}\nTableInlineFilterItem.displayName = \"TableInlineFilterItem\"\n\ninterface FilterValueSelectorProps<TData> {\n  column: Column<TData>\n  value: string\n  onSelect: (value: string) => void\n}\n\nfunction FilterValueSelector<TData>({\n  column,\n  value,\n  onSelect,\n}: FilterValueSelectorProps<TData>) {\n  const variant = column.columnDef.meta?.variant ?? FILTER_VARIANTS.TEXT\n\n  switch (variant) {\n    case FILTER_VARIANTS.BOOLEAN:\n      return (\n        <CommandGroup>\n          <CommandItem value=\"true\" onSelect={() => onSelect(\"true\")}>\n            True\n          </CommandItem>\n          <CommandItem value=\"false\" onSelect={() => onSelect(\"false\")}>\n            False\n          </CommandItem>\n        </CommandGroup>\n      )\n\n    case FILTER_VARIANTS.SELECT:\n    case FILTER_VARIANTS.MULTI_SELECT:\n      return (\n        <CommandGroup>\n          {column.columnDef.meta?.options?.map((option: Option) => (\n            <CommandItem\n              key={option.value}\n              value={option.value}\n              onSelect={() => onSelect(option.value)}\n            >\n              {option.icon && <option.icon />}\n              <span className=\"truncate\">{option.label}</span>\n              {option.count && (\n                <span className=\"ml-auto font-mono text-xs\">\n                  {option.count}\n                </span>\n              )}\n            </CommandItem>\n          ))}\n        </CommandGroup>\n      )\n\n    case FILTER_VARIANTS.DATE:\n    case FILTER_VARIANTS.DATE_RANGE:\n      return (\n        <Calendar\n          mode=\"single\"\n          captionLayout=\"dropdown\"\n          selected={value ? new Date(value) : undefined}\n          onSelect={date => onSelect(date?.getTime().toString() ?? \"\")}\n        />\n      )\n\n    default: {\n      const isEmpty = !value.trim()\n\n      return (\n        <CommandGroup>\n          <CommandItem\n            value={value}\n            onSelect={() => onSelect(value)}\n            disabled={isEmpty}\n          >\n            {isEmpty ? (\n              <>\n                <Text />\n                <span>Type to add filter...</span>\n              </>\n            ) : (\n              <>\n                <BadgeCheck />\n                <span className=\"truncate\">Filter by &quot;{value}&quot;</span>\n              </>\n            )}\n          </CommandItem>\n        </CommandGroup>\n      )\n    }\n  }\n}\nFilterValueSelector.displayName = \"FilterValueSelector\"\n\nfunction onFilterInputRender<TData>({\n  filter,\n  column,\n  inputId,\n  onFilterUpdate,\n  showValueSelector,\n  setShowValueSelector,\n}: {\n  filter: ExtendedColumnFilter<TData>\n  column: Column<TData>\n  inputId: string\n  onFilterUpdate: (\n    filterId: string,\n    updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\n  ) => void\n  showValueSelector: boolean\n  setShowValueSelector: (value: boolean) => void\n}) {\n  if (\n    filter.operator === FILTER_OPERATORS.EMPTY ||\n    filter.operator === FILTER_OPERATORS.NOT_EMPTY\n  ) {\n    return (\n      <div\n        id={inputId}\n        role=\"status\"\n        aria-label={`${column.columnDef.meta?.label} filter is ${\n          filter.operator === FILTER_OPERATORS.EMPTY ? \"empty\" : \"not empty\"\n        }`}\n        aria-live=\"polite\"\n        className=\"h-full w-16 rounded-none border bg-transparent px-1.5 py-0.5 text-muted-foreground dark:bg-input/30\"\n      />\n    )\n  }\n\n  switch (filter.variant) {\n    case FILTER_VARIANTS.TEXT:\n    case FILTER_VARIANTS.NUMBER:\n    case FILTER_VARIANTS.RANGE: {\n      if (\n        (filter.variant === FILTER_VARIANTS.RANGE &&\n          filter.operator === FILTER_OPERATORS.BETWEEN) ||\n        filter.operator === FILTER_OPERATORS.BETWEEN\n      ) {\n        return (\n          <TableRangeFilter\n            filter={filter}\n            column={column}\n            inputId={inputId}\n            onFilterUpdate={onFilterUpdate}\n            className=\"size-full max-w-28 gap-0 **:data-[slot='range-min']:border-r-0 [&_input]:rounded-none [&_input]:px-1.5\"\n          />\n        )\n      }\n\n      const isNumber =\n        filter.variant === FILTER_VARIANTS.NUMBER ||\n        filter.variant === FILTER_VARIANTS.RANGE\n\n      return (\n        <Input\n          id={inputId}\n          type={isNumber ? FILTER_VARIANTS.NUMBER : FILTER_VARIANTS.TEXT}\n          inputMode={isNumber ? \"numeric\" : undefined}\n          placeholder={column.columnDef.meta?.placeholder ?? \"Enter value...\"}\n          className=\"h-full w-24 rounded-none px-1.5\"\n          value={typeof filter.value === \"string\" ? filter.value : \"\"}\n          onChange={event =>\n            onFilterUpdate(filter.filterId, { value: event.target.value })\n          }\n        />\n      )\n    }\n\n    case FILTER_VARIANTS.BOOLEAN: {\n      const inputListboxId = `${inputId}-listbox`\n\n      return (\n        <Select\n          open={showValueSelector}\n          onOpenChange={setShowValueSelector}\n          value={typeof filter.value === \"string\" ? filter.value : \"true\"}\n          onValueChange={(value: \"true\" | \"false\") =>\n            onFilterUpdate(filter.filterId, { value })\n          }\n        >\n          <SelectTrigger\n            id={inputId}\n            aria-controls={inputListboxId}\n            className=\"rounded-none bg-transparent px-1.5 py-0.5 [&_svg]:hidden\"\n          >\n            <SelectValue placeholder={filter.value ? \"True\" : \"False\"} />\n          </SelectTrigger>\n          <SelectContent id={inputListboxId}>\n            <SelectItem value=\"true\">True</SelectItem>\n            <SelectItem value=\"false\">False</SelectItem>\n          </SelectContent>\n        </Select>\n      )\n    }\n\n    case FILTER_VARIANTS.SELECT:\n    case FILTER_VARIANTS.MULTI_SELECT: {\n      const inputListboxId = `${inputId}-listbox`\n\n      const options = column.columnDef.meta?.options ?? []\n      const selectedValues = Array.isArray(filter.value)\n        ? filter.value\n        : [filter.value]\n\n      const selectedOptions = options.filter((option: Option) =>\n        selectedValues.includes(option.value),\n      )\n\n      return (\n        <Popover open={showValueSelector} onOpenChange={setShowValueSelector}>\n          <PopoverTrigger asChild>\n            <Button\n              id={inputId}\n              aria-controls={inputListboxId}\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-full min-w-16 rounded-none border px-1.5 font-normal dark:bg-input/30\"\n            >\n              {selectedOptions.length === 0 ? (\n                filter.variant === FILTER_VARIANTS.MULTI_SELECT ? (\n                  \"Select options...\"\n                ) : (\n                  \"Select option...\"\n                )\n              ) : (\n                <>\n                  <div className=\"flex items-center -space-x-2 rtl:space-x-reverse\">\n                    {selectedOptions.map((selectedOption: Option) =>\n                      selectedOption.icon ? (\n                        <div\n                          key={selectedOption.value}\n                          className=\"rounded-full border bg-background p-0.5\"\n                        >\n                          <selectedOption.icon className=\"size-3.5\" />\n                        </div>\n                      ) : null,\n                    )}\n                  </div>\n                  <span className=\"truncate\">\n                    {selectedOptions.length > 1\n                      ? `${selectedOptions.length} selected`\n                      : selectedOptions[0]?.label}\n                  </span>\n                </>\n              )}\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent\n            id={inputListboxId}\n            align=\"start\"\n            className=\"w-48 origin-(--radix-popover-content-transform-origin) p-0\"\n          >\n            <Command>\n              <CommandInput placeholder=\"Search options...\" />\n              <CommandList>\n                <CommandEmpty>No options found.</CommandEmpty>\n                <CommandGroup>\n                  {options.map((option: Option) => (\n                    <CommandItem\n                      key={option.value}\n                      value={option.value}\n                      onSelect={() => {\n                        const value =\n                          filter.variant === FILTER_VARIANTS.MULTI_SELECT\n                            ? selectedValues.includes(option.value)\n                              ? selectedValues.filter(v => v !== option.value)\n                              : [...selectedValues, option.value]\n                            : option.value\n                        onFilterUpdate(filter.filterId, { value })\n                      }}\n                    >\n                      {option.icon && <option.icon />}\n                      <span className=\"truncate\">{option.label}</span>\n                      {filter.variant === FILTER_VARIANTS.MULTI_SELECT && (\n                        <Check\n                          className={cn(\n                            \"ml-auto\",\n                            selectedValues.includes(option.value)\n                              ? \"opacity-100\"\n                              : \"opacity-0\",\n                          )}\n                        />\n                      )}\n                    </CommandItem>\n                  ))}\n                </CommandGroup>\n              </CommandList>\n            </Command>\n          </PopoverContent>\n        </Popover>\n      )\n    }\n\n    case FILTER_VARIANTS.DATE:\n    case FILTER_VARIANTS.DATE_RANGE: {\n      const inputListboxId = `${inputId}-listbox`\n\n      const dateValue = Array.isArray(filter.value)\n        ? filter.value.filter(Boolean)\n        : [filter.value, filter.value].filter(Boolean)\n\n      const displayValue =\n        filter.operator === FILTER_OPERATORS.BETWEEN && dateValue.length === 2\n          ? `${formatDate(new Date(Number(dateValue[0])))} - ${formatDate(\n              new Date(Number(dateValue[1])),\n            )}`\n          : dateValue[0]\n            ? formatDate(new Date(Number(dateValue[0])))\n            : \"Pick date...\"\n\n      return (\n        <Popover open={showValueSelector} onOpenChange={setShowValueSelector}>\n          <PopoverTrigger asChild>\n            <Button\n              id={inputId}\n              aria-controls={inputListboxId}\n              variant=\"ghost\"\n              size=\"sm\"\n              className={cn(\n                \"h-full rounded-none border px-1.5 font-normal dark:bg-input/30\",\n                !filter.value && \"text-muted-foreground\",\n              )}\n            >\n              <CalendarIcon className=\"size-3.5\" />\n              <span className=\"truncate\">{displayValue}</span>\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent\n            id={inputListboxId}\n            align=\"start\"\n            className=\"w-auto origin-(--radix-popover-content-transform-origin) p-0\"\n          >\n            {filter.operator === FILTER_OPERATORS.BETWEEN ? (\n              <Calendar\n                mode={FILTER_VARIANTS.RANGE}\n                captionLayout=\"dropdown\"\n                selected={\n                  dateValue.length === 2\n                    ? {\n                        from: new Date(Number(dateValue[0])),\n                        to: new Date(Number(dateValue[1])),\n                      }\n                    : {\n                        from: new Date(),\n                        to: new Date(),\n                      }\n                }\n                onSelect={date => {\n                  onFilterUpdate(filter.filterId, {\n                    value: date\n                      ? [\n                          (date.from?.getTime() ?? \"\").toString(),\n                          (date.to?.getTime() ?? \"\").toString(),\n                        ]\n                      : [],\n                  })\n                }}\n              />\n            ) : (\n              <Calendar\n                mode=\"single\"\n                captionLayout=\"dropdown\"\n                selected={\n                  dateValue[0] ? new Date(Number(dateValue[0])) : undefined\n                }\n                onSelect={date => {\n                  onFilterUpdate(filter.filterId, {\n                    value: (date?.getTime() ?? \"\").toString(),\n                  })\n                }}\n              />\n            )}\n          </PopoverContent>\n        </Popover>\n      )\n    }\n\n    default:\n      return null\n  }\n}\n",
      "type": "registry:component",
      "target": "components/niko-table/filters/table-inline-filter.tsx"
    }
  ],
  "type": "registry:component"
}