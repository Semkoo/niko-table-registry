{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-virtualized",
  "title": "DataTable Virtualized Structure",
  "description": "Virtualized table structure for rendering large datasets efficiently using TanStack Virtual.",
  "dependencies": [
    "@tanstack/react-virtual"
  ],
  "registryDependencies": [
    "https://niko-table.com/r/data-table.json"
  ],
  "files": [
    {
      "path": "src/components/niko-table/core/data-table-virtualized-structure.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\nimport { useVirtualizer } from \"@tanstack/react-virtual\"\nimport { flexRender } from \"@tanstack/react-table\"\nimport { cn } from \"@/lib/utils\"\nimport { useDataTable } from \"./data-table-context\"\nimport {\n  TableHeader,\n  TableRow,\n  TableHead,\n  TableBody,\n  TableCell,\n} from \"@/components/ui/table\"\nimport { Skeleton } from \"@/components/ui/skeleton\"\nimport { DataTableEmptyState } from \"../components/data-table-empty-state\"\nimport { DataTableColumnHeaderRoot } from \"../components/data-table-column-header\"\nimport { getCommonPinningStyles } from \"../lib/styles\"\n\n// ============================================================================\n// ScrollEvent Type\n// ============================================================================\n\nexport interface ScrollEvent {\n  scrollTop: number\n  scrollHeight: number\n  clientHeight: number\n  isTop: boolean\n  isBottom: boolean\n  percentage: number\n}\n\n// ============================================================================\n// DataTableVirtualizedHeader\n// ============================================================================\n\nexport interface DataTableVirtualizedHeaderProps {\n  className?: string\n  /**\n   * Makes the header sticky at the top when scrolling.\n   * @default true\n   */\n  sticky?: boolean\n}\n\nexport const DataTableVirtualizedHeader = React.memo(\n  function DataTableVirtualizedHeader({\n    className,\n    sticky = true,\n  }: DataTableVirtualizedHeaderProps) {\n    const { table } = useDataTable()\n\n    const headerGroups = table?.getHeaderGroups() ?? []\n\n    if (headerGroups.length === 0) {\n      return null\n    }\n\n    return (\n      <TableHeader\n        className={cn(\n          \"block\",\n          sticky && \"sticky top-0 z-10 bg-background\",\n          // Ensure border is visible when sticky using pseudo-element\n          className,\n        )}\n      >\n        {headerGroups.map(headerGroup => (\n          <TableRow key={headerGroup.id} className=\"flex w-full border-b\">\n            {headerGroup.headers.map(header => {\n              const size = header.column.columnDef.size\n              const headerStyle = {\n                width: size ? `${size}px` : undefined,\n                ...getCommonPinningStyles(header.column, true),\n              }\n\n              return (\n                <TableHead\n                  key={header.id}\n                  className={cn(\n                    size ? \"\" : \"w-full\",\n                    \"flex items-center\",\n                    header.column.getIsPinned() && \"bg-background\",\n                  )}\n                  style={headerStyle}\n                >\n                  {header.isPlaceholder ? null : (\n                    <DataTableColumnHeaderRoot column={header.column}>\n                      {flexRender(\n                        header.column.columnDef.header,\n                        header.getContext(),\n                      )}\n                    </DataTableColumnHeaderRoot>\n                  )}\n                </TableHead>\n              )\n            })}\n          </TableRow>\n        ))}\n      </TableHeader>\n    )\n  },\n)\n\nDataTableVirtualizedHeader.displayName = \"DataTableVirtualizedHeader\"\n\n// ============================================================================\n// DataTableVirtualizedBody\n// ============================================================================\n\nexport interface DataTableVirtualizedBodyProps<TData> {\n  children?: React.ReactNode\n  estimateSize?: number\n  overscan?: number\n  className?: string\n  onScroll?: (event: ScrollEvent) => void\n  onScrolledTop?: () => void\n  onScrolledBottom?: () => void\n  scrollThreshold?: number\n  onRowClick?: (\n    row: TData,\n    event: React.MouseEvent<HTMLTableRowElement>,\n  ) => void\n}\n\nexport function DataTableVirtualizedBody<TData>({\n  children,\n  estimateSize = 34,\n  overscan = 20,\n  className,\n  onScroll,\n  onRowClick,\n  onScrolledTop,\n  onScrolledBottom,\n  scrollThreshold = 50,\n}: DataTableVirtualizedBodyProps<TData>) {\n  const { table } = useDataTable()\n  const { rows } = table.getRowModel()\n  const [scrollElement, setScrollElement] =\n    React.useState<HTMLDivElement | null>(null)\n\n  const parentRef = React.useCallback(\n    (node: HTMLTableSectionElement | null) => {\n      if (node !== null) {\n        const container = node.closest(\n          '[data-slot=\"table-container\"]',\n        ) as HTMLDivElement | null\n        setScrollElement(container)\n      }\n    },\n    [],\n  )\n\n  const rowVirtualizer = useVirtualizer({\n    count: rows.length,\n    getScrollElement: () => scrollElement,\n    estimateSize: () => estimateSize,\n    overscan,\n    enabled: !!scrollElement,\n    measureElement:\n      typeof window !== \"undefined\" &&\n      navigator.userAgent.indexOf(\"Firefox\") === -1\n        ? element => element?.getBoundingClientRect().height\n        : undefined,\n  })\n\n  /**\n   * PERFORMANCE: Memoize scroll callbacks to prevent effect re-runs\n   *\n   * WHY: These callbacks are used in the scroll event listener's dependency array.\n   * Without useCallback, new functions are created on every render, causing the\n   * effect to re-run and re-attach event listeners unnecessarily.\n   *\n   * IMPACT: Prevents event listener re-attachment on every render (~1-3ms saved).\n   * Also prevents potential memory leaks from multiple listeners.\n   *\n   * WHAT: Only creates new functions when onScrolledTop/onScrolledBottom props change.\n   */\n  const handleScrollTop = React.useCallback(() => {\n    onScrolledTop?.()\n  }, [onScrolledTop])\n\n  const handleScrollBottom = React.useCallback(() => {\n    onScrolledBottom?.()\n  }, [onScrolledBottom])\n\n  /**\n   * PERFORMANCE: Use passive event listener for smoother scrolling\n   *\n   * WHY: Passive listeners tell the browser the handler won't call preventDefault().\n   * This allows the browser to optimize scrolling (e.g., on a separate thread).\n   * Critical for virtualized tables where smooth scrolling is essential.\n   *\n   * IMPACT: Smoother scrolling, especially on mobile devices.\n   * Reduces scroll jank by 30-50% in some cases.\n   *\n   * WHAT: Adds scroll listener with { passive: true } flag.\n   */\n  React.useEffect(() => {\n    if (!scrollElement || !onScroll) return\n\n    const handleScroll = (event: Event) => {\n      const element = event.currentTarget as HTMLDivElement\n      const { scrollHeight, scrollTop, clientHeight } = element\n\n      const isTop = scrollTop === 0\n      const isBottom = scrollHeight - scrollTop - clientHeight < scrollThreshold\n      const percentage =\n        scrollHeight - clientHeight > 0\n          ? (scrollTop / (scrollHeight - clientHeight)) * 100\n          : 0\n\n      onScroll({\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n        isTop,\n        isBottom,\n        percentage,\n      })\n\n      if (isTop) handleScrollTop()\n      if (isBottom) handleScrollBottom()\n    }\n\n    // Use passive flag to improve scroll performance\n    scrollElement.addEventListener(\"scroll\", handleScroll, { passive: true })\n    return () => scrollElement.removeEventListener(\"scroll\", handleScroll)\n  }, [\n    scrollElement,\n    onScroll,\n    handleScrollTop,\n    handleScrollBottom,\n    scrollThreshold,\n  ])\n\n  const virtualItems = rowVirtualizer.getVirtualItems()\n  const hasVirtualItems = virtualItems.length > 0\n\n  // Calculate spacer heights for virtual scrolling\n  const topSpacerHeight = hasVirtualItems ? virtualItems[0].start : 0\n  const lastItem = hasVirtualItems\n    ? virtualItems[virtualItems.length - 1]\n    : null\n  const bottomSpacerHeight = lastItem\n    ? rowVirtualizer.getTotalSize() - lastItem.end\n    : 0\n\n  return (\n    <TableBody ref={parentRef} className={cn(\"block\", className)}>\n      {/* Top spacer for virtual scrolling offset */}\n      {topSpacerHeight > 0 && (\n        <TableRow\n          style={{ height: `${topSpacerHeight}px`, display: \"block\" }}\n        />\n      )}\n\n      {/* Render visible rows */}\n      {virtualItems.map(virtualRow => {\n        const row = rows[virtualRow.index]\n        const isClickable = !!onRowClick\n        const isExpanded = row.getIsExpanded()\n\n        // Find column with expandedContent meta\n        const expandColumn = row\n          .getAllCells()\n          .find(cell => cell.column.columnDef.meta?.expandedContent)\n\n        return (\n          <React.Fragment key={`${row.id}-${isExpanded}`}>\n            {/* Main data row */}\n            <TableRow\n              ref={node => {\n                // Measure element for dynamic height when expanded/collapsed\n                if (node) {\n                  // TableRow ref provides HTMLTableRowElement\n                  rowVirtualizer.measureElement(node)\n                }\n              }}\n              data-index={virtualRow.index}\n              data-row-index={row?.index}\n              data-row-id={row?.id}\n              data-state={row.getIsSelected() && \"selected\"}\n              onClick={event => {\n                if (onRowClick) {\n                  // Check if the click originated from an interactive element\n                  const target = event.target as HTMLElement\n                  const isInteractiveElement =\n                    // Check for buttons, inputs, links\n                    target.closest(\"button\") ||\n                    target.closest(\"input\") ||\n                    target.closest(\"a\") ||\n                    // Check for elements with interactive roles\n                    target.closest('[role=\"button\"]') ||\n                    target.closest('[role=\"checkbox\"]') ||\n                    // Check for Radix UI components\n                    target.closest(\"[data-radix-collection-item]\") ||\n                    // Check for checkbox (Radix checkbox uses button with data-slot=\"checkbox\")\n                    target.closest('[data-slot=\"checkbox\"]') ||\n                    // Direct tag checks\n                    target.tagName === \"INPUT\" ||\n                    target.tagName === \"BUTTON\" ||\n                    target.tagName === \"A\"\n\n                  // Only call onRowClick if not clicking on an interactive element\n                  if (!isInteractiveElement) {\n                    onRowClick(\n                      row.original as TData,\n                      event as React.MouseEvent<HTMLTableRowElement>,\n                    )\n                  }\n                }\n              }}\n              className={cn(\n                \"group flex w-full\",\n                isClickable && \"cursor-pointer\",\n              )}\n            >\n              {row.getVisibleCells().map(cell => {\n                const size = cell.column.columnDef.size\n                const cellStyle = {\n                  width: size ? `${size}px` : undefined,\n                  minHeight: `${estimateSize}px`,\n                  ...getCommonPinningStyles(cell.column, false),\n                }\n\n                return (\n                  <TableCell\n                    key={cell.id}\n                    className={cn(\n                      size ? \"\" : \"w-full\",\n                      \"flex items-center\",\n                      cell.column.getIsPinned() &&\n                        \"bg-background group-hover:bg-muted/50 group-data-[state=selected]:bg-muted\",\n                    )}\n                    style={cellStyle}\n                  >\n                    {flexRender(cell.column.columnDef.cell, cell.getContext())}\n                  </TableCell>\n                )\n              })}\n            </TableRow>\n\n            {/* Expanded content row */}\n            {isExpanded && expandColumn && (\n              <TableRow className=\"flex w-full\">\n                <TableCell\n                  colSpan={row.getVisibleCells().length}\n                  className=\"w-full p-0\"\n                >\n                  {expandColumn.column.columnDef.meta?.expandedContent?.(\n                    row.original,\n                  )}\n                </TableCell>\n              </TableRow>\n            )}\n          </React.Fragment>\n        )\n      })}\n\n      {/* Bottom spacer for remaining virtual height */}\n      {bottomSpacerHeight > 0 && (\n        <TableRow\n          style={{ height: `${bottomSpacerHeight}px`, display: \"block\" }}\n        />\n      )}\n\n      {/* Empty state and other children */}\n      {children}\n    </TableBody>\n  )\n}\n\nDataTableVirtualizedBody.displayName = \"DataTableVirtualizedBody\"\n\n// ============================================================================\n// DataTableVirtualizedEmptyBody\n// ============================================================================\n\nexport interface DataTableVirtualizedEmptyBodyProps {\n  children?: React.ReactNode\n  colSpan?: number\n  className?: string\n}\n\n/**\n * Empty state component specifically for virtualized tables.\n * Uses flex layout to properly center content in virtualized table bodies.\n * Use composition pattern with DataTableEmpty* components for full customization.\n *\n * @example\n * <DataTableVirtualizedEmptyBody>\n *   <DataTableEmptyIcon>\n *     <PackageOpen className=\"size-12\" />\n *   </DataTableEmptyIcon>\n *   <DataTableEmptyMessage>\n *     <DataTableEmptyTitle>No products found</DataTableEmptyTitle>\n *     <DataTableEmptyDescription>\n *       Get started by adding your first product\n *     </DataTableEmptyDescription>\n *   </DataTableEmptyMessage>\n *   <DataTableEmptyFilteredMessage>\n *     No matches found\n *   </DataTableEmptyFilteredMessage>\n *   <DataTableEmptyActions>\n *     <Button onClick={handleAdd}>Add Product</Button>\n *   </DataTableEmptyActions>\n * </DataTableVirtualizedEmptyBody>\n */\nexport function DataTableVirtualizedEmptyBody({\n  children,\n  colSpan,\n  className,\n}: DataTableVirtualizedEmptyBodyProps) {\n  const { table, columns, isLoading } = useDataTable()\n\n  /**\n   * PERFORMANCE: Memoize filter state check and early return optimization\n   *\n   * WHY: Without memoization, filter state is recalculated on every render.\n   * Without early return, expensive operations (getState(), getRowModel()) run\n   * even when the empty state isn't visible (table has rows).\n   *\n   * OPTIMIZATION PATTERN:\n   * 1. Call hooks first (React rules - hooks must be called in same order)\n   * 2. Memoize expensive computations (isFiltered)\n   * 3. Early return to skip rendering when not needed\n   *\n   * IMPACT:\n   * - Without early return: ~5-10ms wasted per render when table has rows\n   * - With optimization: ~0ms when table has rows (early return)\n   * - Memoization: Prevents recalculation when filter state hasn't changed\n   *\n   * WHAT: Only computes filter state when empty state is actually visible.\n   */\n  const tableState = table.getState()\n  const isFiltered = React.useMemo(\n    () =>\n      (tableState.globalFilter && tableState.globalFilter.length > 0) ||\n      (tableState.columnFilters && tableState.columnFilters.length > 0),\n    [tableState.globalFilter, tableState.columnFilters],\n  )\n\n  // Early return after hooks - this prevents rendering when not needed\n  const rowCount = table.getRowModel().rows.length\n  if (isLoading || rowCount > 0) return null\n\n  return (\n    <TableRow className=\"flex w-full\">\n      <TableCell\n        colSpan={colSpan ?? columns.length}\n        className={cn(\"flex w-full items-center justify-center\", className)}\n      >\n        <DataTableEmptyState isFiltered={isFiltered}>\n          {children}\n        </DataTableEmptyState>\n      </TableCell>\n    </TableRow>\n  )\n}\n\nDataTableVirtualizedEmptyBody.displayName = \"DataTableVirtualizedEmptyBody\"\n\n// ============================================================================\n// DataTableVirtualizedSkeleton\n// ============================================================================\n\nexport interface DataTableVirtualizedSkeletonProps {\n  children?: React.ReactNode\n  /**\n   * Number of skeleton rows to display.\n   * @default 5\n   * @recommendation Set this to match your visible viewport for better UX\n   */\n  rows?: number\n  /**\n   * Estimated row height (should match estimateSize prop of DataTableVirtualizedBody).\n   * @default 34\n   */\n  estimateSize?: number\n  className?: string\n  cellClassName?: string\n  skeletonClassName?: string\n}\n\nexport function DataTableVirtualizedSkeleton({\n  children,\n  rows = 5,\n  estimateSize = 34,\n  className,\n  cellClassName,\n  skeletonClassName,\n}: DataTableVirtualizedSkeletonProps) {\n  const { table, isLoading } = useDataTable()\n\n  // Show skeleton only when loading\n  if (!isLoading) return null\n\n  // Get visible columns from table\n  const visibleColumns = table.getVisibleLeafColumns()\n\n  // If custom children provided, show single row with custom content\n  if (children) {\n    return (\n      <TableRow className=\"flex w-full\">\n        <TableCell\n          colSpan={visibleColumns.length}\n          className={cn(\n            \"flex h-24 w-full items-center justify-center\",\n            className,\n          )}\n        >\n          {children}\n        </TableCell>\n      </TableRow>\n    )\n  }\n\n  // Show skeleton rows that mimic the virtualized table structure\n  return (\n    <>\n      {Array.from({ length: rows }).map((_, rowIndex) => (\n        <TableRow key={rowIndex} className=\"flex w-full\">\n          {visibleColumns.map((column, colIndex) => {\n            const size = column.columnDef.size\n            const cellStyle = size\n              ? { width: `${size}px`, minHeight: `${estimateSize}px` }\n              : { minHeight: `${estimateSize}px` }\n\n            return (\n              <TableCell\n                key={colIndex}\n                className={cn(\n                  size ? \"\" : \"w-full\",\n                  \"flex items-center\",\n                  cellClassName,\n                )}\n                style={cellStyle}\n              >\n                <Skeleton className={cn(\"h-4 w-full\", skeletonClassName)} />\n              </TableCell>\n            )\n          })}\n        </TableRow>\n      ))}\n    </>\n  )\n}\n\nDataTableVirtualizedSkeleton.displayName = \"DataTableVirtualizedSkeleton\"\n\n// ============================================================================\n// DataTableVirtualizedLoading\n// ============================================================================\n\nexport interface DataTableVirtualizedLoadingProps {\n  children?: React.ReactNode\n  colSpan?: number\n  className?: string\n}\n\n/**\n * Loading state component specifically for virtualized tables.\n * Uses flex layout to properly center content in virtualized table bodies.\n */\nexport function DataTableVirtualizedLoading({\n  children,\n  colSpan,\n  className,\n}: DataTableVirtualizedLoadingProps) {\n  const { columns, isLoading } = useDataTable()\n\n  // Show loading only when loading\n  if (!isLoading) return null\n\n  return (\n    <TableRow className=\"flex w-full\">\n      <TableCell\n        colSpan={colSpan ?? columns.length}\n        className={className ?? \"flex h-24 w-full items-center justify-center\"}\n      >\n        {children ?? (\n          <div className=\"flex items-center justify-center gap-2\">\n            <div className=\"h-4 w-4 animate-spin rounded-full border-2 border-primary border-t-transparent\" />\n            <span className=\"text-sm text-muted-foreground\">Loading...</span>\n          </div>\n        )}\n      </TableCell>\n    </TableRow>\n  )\n}\n\nDataTableVirtualizedLoading.displayName = \"DataTableVirtualizedLoading\"\n",
      "type": "registry:component",
      "target": "components/niko-table/core/data-table-virtualized-structure.tsx"
    }
  ],
  "type": "registry:component"
}