{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-column-slider-filter",
  "title": "DataTable Column Slider Filter",
  "description": "Column header slider filter for numeric range filtering in a dropdown.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "https://niko-table.com/r/data-table.json",
    "button",
    "dropdown-menu",
    "tooltip",
    "input",
    "label",
    "slider"
  ],
  "files": [
    {
      "path": "src/components/niko-table/components/data-table-column-slider-filter-options.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\nimport type { Column } from \"@tanstack/react-table\"\n\nimport { TableColumnSliderFilterOptions } from \"../filters/table-column-slider-filter\"\nimport { useColumnHeaderContext } from \"./data-table-column-header\"\n\n/**\n * Slider filter options for composing inside DataTableColumnActions using context.\n */\nexport function DataTableColumnSliderFilterOptions<TData, TValue>(\n  props: Omit<\n    React.ComponentProps<typeof TableColumnSliderFilterOptions>,\n    \"column\"\n  > & {\n    column?: Column<TData, TValue>\n  },\n) {\n  const context = useColumnHeaderContext<TData, TValue>(false)\n  const column = props.column || context?.column\n\n  if (!column) {\n    console.warn(\n      \"DataTableColumnSliderFilterOptions must be used within DataTableColumnHeaderRoot or provided with a column prop\",\n    )\n    return null\n  }\n\n  return <TableColumnSliderFilterOptions column={column} {...props} />\n}\n\nDataTableColumnSliderFilterOptions.displayName =\n  \"DataTableColumnSliderFilterOptions\"\n",
      "type": "registry:component",
      "target": "components/niko-table/components/data-table-column-slider-filter-options.tsx"
    },
    {
      "path": "src/components/niko-table/filters/table-column-slider-filter.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\nimport type { Column } from \"@tanstack/react-table\"\nimport { CircleHelp } from \"lucide-react\"\n\nimport {\n  DropdownMenuSeparator,\n  DropdownMenuLabel,\n} from \"@/components/ui/dropdown-menu\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport { Button } from \"@/components/ui/button\"\nimport { Slider } from \"@/components/ui/slider\"\nimport { cn } from \"@/lib/utils\"\nimport { useDerivedColumnTitle } from \"../hooks\"\n\ntype RangeValue = [number, number]\n\nfunction parseValuesAsNumbers(value: unknown): RangeValue | undefined {\n  if (\n    Array.isArray(value) &&\n    value.length === 2 &&\n    value.every(\n      v => (typeof v === \"string\" || typeof v === \"number\") && !Number.isNaN(v),\n    )\n  ) {\n    return [Number(value[0]), Number(value[1])]\n  }\n\n  return undefined\n}\n\nfunction getIsValidRange(value: unknown): value is RangeValue {\n  return (\n    Array.isArray(value) &&\n    value.length === 2 &&\n    typeof value[0] === \"number\" &&\n    typeof value[1] === \"number\"\n  )\n}\n\n/**\n * Slider filter options for composing inside TableColumnActions.\n * Renders as inline slider with min/max inputs.\n *\n * @example\n * ```tsx\n * // Inside TableColumnActions\n * <TableColumnActions column={column}>\n *   <TableColumnSliderFilterOptions\n *     column={column}\n *     min={0}\n *     max={1000}\n *   />\n * </TableColumnActions>\n * ```\n */\nexport function TableColumnSliderFilterOptions<TData, TValue>({\n  column,\n  title,\n  range: manualRange,\n  min: manualMin,\n  max: manualMax,\n  step: manualStep,\n  unit: manualUnit,\n  onValueChange,\n  withSeparator = true,\n}: {\n  column: Column<TData, TValue>\n  title?: string\n  /**\n   * Manual range [min, max] (overrides min/max props and column.meta.range)\n   */\n  range?: RangeValue\n  /**\n   * Manual minimum value (overrides column.meta.range and faceted values)\n   */\n  min?: number\n  /**\n   * Manual maximum value (overrides column.meta.range and faceted values)\n   */\n  max?: number\n  /**\n   * Manual step value for the slider\n   */\n  step?: number\n  /**\n   * Unit label to display (e.g., \"$\", \"kg\", \"km\")\n   */\n  unit?: string\n  onValueChange?: (value: [number, number] | undefined) => void\n  /** Whether to render a separator before the options. Defaults to true. */\n  withSeparator?: boolean\n}) {\n  const id = React.useId()\n\n  const columnFilterValue = parseValuesAsNumbers(column.getFilterValue())\n\n  const defaultRange = column.columnDef.meta?.range\n  const unit = manualUnit ?? column.columnDef.meta?.unit\n\n  // Compute range values - memoized to avoid recalculation\n  const { min, max, step } = React.useMemo<{\n    min: number\n    max: number\n    step: number\n  }>(() => {\n    let minValue = 0\n    let maxValue = 100\n\n    // Priority 1: Manual range prop (highest priority)\n    if (manualRange && getIsValidRange(manualRange)) {\n      minValue = manualRange[0]\n      maxValue = manualRange[1]\n    }\n    // Priority 2: Manual min/max props\n    else if (manualMin != null && manualMax != null) {\n      minValue = manualMin\n      maxValue = manualMax\n    }\n    // Priority 3: Use explicit range from column metadata\n    else if (defaultRange && getIsValidRange(defaultRange)) {\n      minValue = defaultRange[0]\n      maxValue = defaultRange[1]\n    }\n    // Priority 4: Get min/max from faceted values\n    else {\n      const facetedValues = column.getFacetedMinMaxValues()\n      if (facetedValues?.[0] != null && facetedValues?.[1] != null) {\n        minValue = Number(facetedValues[0])\n        maxValue = Number(facetedValues[1])\n      }\n    }\n\n    // Calculate appropriate step size based on range\n    const rangeSize = maxValue - minValue\n    const calculatedStep =\n      rangeSize <= 20\n        ? 1\n        : rangeSize <= 100\n          ? Math.ceil(rangeSize / 20)\n          : Math.ceil(rangeSize / 50)\n\n    return {\n      min: minValue,\n      max: maxValue,\n      step: manualStep ?? calculatedStep,\n    }\n  }, [column, defaultRange, manualRange, manualMin, manualMax, manualStep])\n\n  const range = React.useMemo((): RangeValue => {\n    return columnFilterValue ?? [min, max]\n  }, [columnFilterValue, min, max])\n\n  const derivedTitle = useDerivedColumnTitle(column, column.id, title)\n  const labelText = \"Range Filter\"\n  const tooltipText = \"Set a range to filter values\"\n\n  const applyFilterValue = React.useCallback(\n    (value: [number, number] | undefined) => {\n      column.setFilterValue(value)\n      onValueChange?.(value)\n    },\n    [column, onValueChange],\n  )\n\n  const onRangeValueChange = React.useCallback(\n    (value: string | number, isMin?: boolean) => {\n      const numValue = Number(value)\n      const currentValues = range\n\n      if (value === \"\") {\n        // Allow empty value, don't update filter\n        return\n      }\n\n      if (\n        !Number.isNaN(numValue) &&\n        (isMin\n          ? numValue >= min && numValue <= currentValues[1]\n          : numValue <= max && numValue >= currentValues[0])\n      ) {\n        applyFilterValue(\n          isMin ? [numValue, currentValues[1]] : [currentValues[0], numValue],\n        )\n      }\n    },\n    [min, max, range, applyFilterValue],\n  )\n\n  const onSliderValueChange = React.useCallback(\n    (value: RangeValue) => {\n      if (Array.isArray(value) && value.length === 2) {\n        applyFilterValue(value)\n      }\n    },\n    [applyFilterValue],\n  )\n\n  const onReset = React.useCallback(() => {\n    applyFilterValue(undefined)\n  }, [applyFilterValue])\n\n  return (\n    <>\n      {withSeparator && <DropdownMenuSeparator />}\n      <DropdownMenuLabel className=\"flex items-center justify-between text-xs font-normal text-muted-foreground\">\n        <span>{labelText}</span>\n        <Tooltip>\n          <TooltipTrigger asChild>\n            <CircleHelp className=\"size-3.5 cursor-help\" />\n          </TooltipTrigger>\n          <TooltipContent side=\"right\">\n            {tooltipText}\n            {derivedTitle && ` - ${derivedTitle}`}\n          </TooltipContent>\n        </Tooltip>\n      </DropdownMenuLabel>\n      <div className=\"px-2 py-2\">\n        <div className=\"flex flex-col gap-3\">\n          <div className=\"flex items-center gap-2\">\n            <Label htmlFor={`${id}-from`} className=\"sr-only\">\n              From\n            </Label>\n            <div className=\"relative flex-1\">\n              <Input\n                key={`${id}-from-${range[0]}`}\n                id={`${id}-from`}\n                type=\"number\"\n                aria-label={`${derivedTitle} minimum value`}\n                aria-valuemin={min}\n                aria-valuemax={max}\n                inputMode=\"numeric\"\n                pattern=\"[0-9]*\"\n                placeholder={min.toString()}\n                min={min}\n                max={max}\n                defaultValue={range[0]}\n                onChange={event =>\n                  onRangeValueChange(String(event.target.value), true)\n                }\n                className={cn(\"h-8 w-full\", unit && \"pr-8\")}\n              />\n              {unit && (\n                <span className=\"absolute top-0 right-0 bottom-0 mt-0.5 mr-0.5 flex h-7 items-center rounded-r-md bg-accent px-2 text-sm text-muted-foreground\">\n                  {unit}\n                </span>\n              )}\n            </div>\n            <Label htmlFor={`${id}-to`} className=\"sr-only\">\n              to\n            </Label>\n            <div className=\"relative flex-1\">\n              <Input\n                key={`${id}-to-${range[1]}`}\n                id={`${id}-to`}\n                type=\"number\"\n                aria-label={`${derivedTitle} maximum value`}\n                aria-valuemin={min}\n                aria-valuemax={max}\n                inputMode=\"numeric\"\n                pattern=\"[0-9]*\"\n                placeholder={max.toString()}\n                min={min}\n                max={max}\n                defaultValue={range[1]}\n                onChange={event =>\n                  onRangeValueChange(String(event.target.value))\n                }\n                className={cn(\"h-8 w-full\", unit && \"pr-8\")}\n              />\n              {unit && (\n                <span className=\"absolute top-0 right-0 bottom-0 mt-0.5 mr-0.5 flex h-7 items-center rounded-r-md bg-accent px-2 text-sm text-muted-foreground\">\n                  {unit}\n                </span>\n              )}\n            </div>\n          </div>\n          <Label htmlFor={`${id}-slider`} className=\"sr-only\">\n            {derivedTitle} slider\n          </Label>\n          <Slider\n            id={`${id}-slider`}\n            min={min}\n            max={max}\n            step={step}\n            value={range}\n            onValueChange={onSliderValueChange}\n            className=\"w-full\"\n          />\n          <Button\n            aria-label={`Clear ${derivedTitle} filter`}\n            variant=\"outline\"\n            size=\"sm\"\n            onClick={onReset}\n            className=\"w-full\"\n          >\n            Clear\n          </Button>\n        </div>\n      </div>\n    </>\n  )\n}\n\nTableColumnSliderFilterOptions.displayName = \"TableColumnSliderFilterOptions\"\n",
      "type": "registry:component",
      "target": "components/niko-table/filters/table-column-slider-filter.tsx"
    }
  ],
  "type": "registry:component"
}