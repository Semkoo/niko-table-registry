{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-filter-menu",
  "title": "DataTable Filter Menu",
  "description": "Command palette-style filter interface for adding and managing column filters.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "https://niko-table.com/r/data-table.json",
    "button",
    "badge",
    "input",
    "popover",
    "command",
    "select",
    "calendar",
    "separator"
  ],
  "files": [
    {
      "path": "src/components/niko-table/components/data-table-filter-menu.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\nimport { useDataTable } from \"../core\"\nimport { TableFilterMenu } from \"../filters/table-filter-menu\"\nimport { useGeneratedOptions } from \"../hooks/use-generated-options\"\nimport { FILTER_VARIANTS } from \"../lib/constants\"\nimport type { Option } from \"../types\"\n\ntype BaseTableFilterMenuProps<TData> = Omit<\n  React.ComponentProps<typeof TableFilterMenu<TData>>,\n  \"table\"\n>\n\ninterface AutoOptionProps {\n  /**\n   * Automatically generate select/multi_select options for columns lacking static options\n   * @default true\n   */\n  autoOptions?: boolean\n  /** Show counts beside each option (computed from rows) */\n  showCounts?: boolean\n  /** Recompute counts based on currently filtered rows */\n  dynamicCounts?: boolean\n  /**\n   * If true, only generate options from filtered rows. If false, generate from all rows.\n   * This controls which rows are used to generate the option list itself.\n   * Note: This is separate from dynamicCounts which controls count calculation.\n   * @default true\n   */\n  limitToFilteredRows?: boolean\n  /** Only generate options for these column ids */\n  includeColumns?: string[]\n  /** Exclude these column ids from generation */\n  excludeColumns?: string[]\n  /** Limit number of generated options per column */\n  limitPerColumn?: number\n  /**\n   * Merge strategy when static options already exist:\n   * - \"preserve\" keeps user options untouched (default)\n   * - \"augment\" adds counts to matching values\n   * - \"replace\" overrides with generated options\n   */\n  mergeStrategy?: \"preserve\" | \"augment\" | \"replace\"\n}\n\ntype DataTableFilterMenuProps<TData> = BaseTableFilterMenuProps<TData> &\n  AutoOptionProps\n\n/**\n * A filter menu component that automatically connects to the DataTable context.\n * Filters are managed directly by the table state - no internal state needed.\n *\n * @example - Basic usage\n * <DataTableFilterMenu />\n *\n * @example - Custom alignment and positioning\n * <DataTableFilterMenu align=\"end\" side=\"bottom\" />\n *\n * @example - Custom styling\n * <DataTableFilterMenu className=\"w-[400px]\" />\n */\nexport function DataTableFilterMenu<TData>({\n  autoOptions = true,\n  showCounts = true,\n  dynamicCounts = true,\n  limitToFilteredRows = true,\n  includeColumns,\n  excludeColumns,\n  limitPerColumn,\n  mergeStrategy = \"preserve\",\n  ...props\n}: DataTableFilterMenuProps<TData>) {\n  const { table } = useDataTable<TData>()\n\n  // Generate options map (only includes select/multi_select columns)\n  const generatedOptions = useGeneratedOptions(table, {\n    showCounts,\n    dynamicCounts,\n    limitToFilteredRows,\n    includeColumns,\n    excludeColumns,\n    limitPerColumn,\n  })\n\n  // Apply generated options according to mergeStrategy.\n  // We mutate columnDef.meta.options safely inside memo to avoid extra renders.\n  React.useMemo(() => {\n    if (!autoOptions) return\n    table.getAllColumns().forEach(column => {\n      const meta = (column.columnDef.meta ||= {})\n      const variant = meta.variant ?? FILTER_VARIANTS.TEXT\n      if (\n        variant !== FILTER_VARIANTS.SELECT &&\n        variant !== FILTER_VARIANTS.MULTI_SELECT\n      )\n        return\n      const gen = generatedOptions[column.id]\n      if (!gen || gen.length === 0) return\n\n      if (!meta.options) {\n        meta.options = gen\n        return\n      }\n\n      if (mergeStrategy === \"replace\") {\n        meta.options = gen\n        return\n      }\n\n      if (mergeStrategy === \"augment\") {\n        const countMap = new Map(gen.map(o => [o.value, o.count]))\n        meta.options = meta.options.map((opt: Option) => ({\n          ...opt,\n          count: showCounts\n            ? (countMap.get(opt.value) ?? opt.count)\n            : undefined,\n        }))\n      }\n      // preserve: do nothing\n    })\n  }, [autoOptions, generatedOptions, mergeStrategy, showCounts, table])\n\n  return <TableFilterMenu<TData> table={table} {...props} />\n}\n\n/**\n * @required displayName is required for auto feature detection\n * @see \"feature-detection.ts\"\n */\nDataTableFilterMenu.displayName = \"DataTableFilterMenu\"\n",
      "type": "registry:component",
      "target": "components/niko-table/components/data-table-filter-menu.tsx"
    },
    {
      "path": "src/components/niko-table/filters/table-filter-menu.tsx",
      "content": "\"use client\"\n\n/**\n * Table filter menu component\n * @description A filter menu component for DataTable that allows users to manage multiple filtering criteria. Users can add, remove, and reorder filters, select fields, operators, and input values.\n *\n * @architecture\n * This file is organized into sections for easy copy-paste:\n *\n * 1. **Utilities** (createFilterId) - Helper functions\n *\n * 2. **Custom Hooks** - Replace useEffect with composable logic:\n *    - useInitialFilters: Extracts initial state from table (replaces initialization useEffect)\n *    - useSyncFiltersWithTable: Syncs filters to table state (replaces sync useEffect)\n *\n * 3. **Filter Input Components** - Small, focused components for each input type:\n *    - FilterEmptyInput: Empty state for isEmpty/isNotEmpty\n *    - FilterTextNumberInput: Text/number inputs\n *    - FilterBooleanSelect: Boolean dropdown\n *    - FilterFacetedSelect: Single/multi-select faceted component\n *    - FilterDatePicker: Date/date range picker\n *    - FilterValueInput: Main router component that renders correct input\n *\n * 4. **Filter Item Sub-Components** - Break down filter row UI:\n *    - FilterJoinOperator: AND/OR selector\n *    - FilterFieldSelector: Column field picker\n *    - FilterOperatorSelector: Operator picker (equals, contains, etc.)\n *\n * 5. **Main Components**:\n *    - DataTableFilterItem: Single filter row (uses sub-components)\n *    - TableFilterMenu: Main popover with filter list\n *\n * @debugging\n * - All components have displayName for React DevTools\n * - Development-only console.log statements in hooks (NODE_ENV check)\n * - Check table.getState() to see current filter state\n * - Use React DevTools Components tab to inspect component tree\n * - Filter data flow: User Input → onFilterUpdate → filters state → useSyncFiltersWithTable → table state\n */\n\nimport type { Column, Table } from \"@tanstack/react-table\"\nimport {\n  CalendarIcon,\n  Check,\n  ChevronsUpDown,\n  Grip,\n  ListFilter,\n  Trash2,\n} from \"lucide-react\"\nimport * as React from \"react\"\n\nimport { TableRangeFilter } from \"./table-range-filter\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { Button } from \"@/components/ui/button\"\nimport { Calendar } from \"@/components/ui/calendar\"\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\"\nimport { Input } from \"@/components/ui/input\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\"\nimport {\n  Sortable,\n  SortableContent,\n  SortableItem,\n  SortableItemHandle,\n  SortableOverlay,\n} from \"@/components/ui/sortable\"\nimport { dataTableConfig } from \"../config/data-table\"\nimport {\n  getDefaultFilterOperator,\n  getFilterOperators,\n  processFiltersForLogic,\n} from \"../lib/data-table\"\nimport { formatDate } from \"../lib/format\"\nimport { useKeyboardShortcut } from \"../hooks\"\nimport { cn } from \"@/lib/utils\"\nimport {\n  FILTER_OPERATORS,\n  FILTER_VARIANTS,\n  JOIN_OPERATORS,\n  ERROR_MESSAGES,\n  KEYBOARD_SHORTCUTS,\n} from \"../lib/constants\"\nimport type {\n  ExtendedColumnFilter,\n  FilterOperator,\n  JoinOperator,\n  Option,\n} from \"../types\"\n\n/* --------------------------------- Utilities -------------------------------- */\n\n/**\n * Create a deterministic filter ID based on filter properties\n * This ensures filters can be shared via URL and will have consistent IDs\n */\nfunction createFilterId<TData>(\n  filter: Omit<ExtendedColumnFilter<TData>, \"filterId\">,\n  index?: number,\n): string {\n  // Create a deterministic ID based on filter properties\n  // Using a combination that should be unique for each filter configuration\n  const valueStr =\n    typeof filter.value === \"string\"\n      ? filter.value\n      : JSON.stringify(filter.value)\n\n  // Include index as a fallback to ensure uniqueness for URL sharing\n  const indexSuffix = typeof index === FILTER_VARIANTS.NUMBER ? `-${index}` : \"\"\n\n  return `${filter.id}-${filter.operator}-${filter.variant}-${valueStr}${indexSuffix}`\n    .toLowerCase()\n    .replace(/[^a-z0-9-]/g, \"-\")\n    .replace(/-+/g, \"-\")\n    .substring(0, 100) // Limit length to avoid extremely long IDs\n}\n\n/**\n * Create a unique key for a filter based on its properties (not filterId)\n * This allows matching filters even if filterId is changed in the URL\n */\nfunction getFilterKey<TData>(filter: ExtendedColumnFilter<TData>): string {\n  const valueStr =\n    typeof filter.value === \"string\"\n      ? filter.value\n      : Array.isArray(filter.value)\n        ? filter.value.join(\",\")\n        : JSON.stringify(filter.value)\n  return `${filter.id}-${filter.operator}-${filter.variant}-${valueStr}`\n}\n\n/**\n * Type for filters without filterId (for URL serialization)\n */\ntype FilterWithoutId<TData> = Omit<ExtendedColumnFilter<TData>, \"filterId\">\n\n/**\n * Normalize filters loaded from URL by ensuring they have filterId\n * If filterId is missing, generate it deterministically\n *\n * This allows filters to be stored in URL without filterId, making URLs shorter\n * and more robust. The filterId is auto-generated when filters are loaded.\n *\n * @param filters - Filters that may or may not have filterId\n * @returns Filters with guaranteed filterId values\n */\nfunction normalizeFiltersFromUrl<TData>(\n  filters: (FilterWithoutId<TData> | ExtendedColumnFilter<TData>)[],\n): ExtendedColumnFilter<TData>[] {\n  // Quick check: if all filters already have filterIds, return as-is\n  // This preserves object and array references\n  const hasAllIds = filters.every(\n    (f): f is ExtendedColumnFilter<TData> => \"filterId\" in f && !!f.filterId,\n  )\n  if (hasAllIds) {\n    return filters as ExtendedColumnFilter<TData>[]\n  }\n\n  return filters.map((filter, index) => {\n    // If filterId is missing, generate it\n    if (!(\"filterId\" in filter) || !filter.filterId) {\n      return {\n        ...filter,\n        filterId: createFilterId(filter, index),\n      } as ExtendedColumnFilter<TData>\n    }\n    return filter as ExtendedColumnFilter<TData>\n  })\n}\n\n/**\n * Serialize filters for URL (excludes filterId to make URLs shorter)\n *\n * OPTIONAL: Use this function when serializing filters to URL to exclude filterId.\n * The filterId will be auto-generated when filters are loaded from URL via\n * normalizeFiltersFromUrl(), so it's safe to exclude it.\n *\n * Example usage in URL state management:\n * ```ts\n * const urlFilters = serializeFiltersForUrl(filters)\n * setUrlParams({ filters: urlFilters })\n * ```\n *\n * @param filters - Filters with filterId\n * @returns Filters without filterId (suitable for URL storage)\n */\nexport function serializeFiltersForUrl<TData>(\n  filters: ExtendedColumnFilter<TData>[],\n): FilterWithoutId<TData>[] {\n  return filters.map(filter => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { filterId, ...filterWithoutId } = filter\n    return filterWithoutId\n  })\n}\n\n/* --------------------------------- Faceted Component (Inline) -------------------------------- */\n\n/**\n * Faceted component for single/multi-select filters\n * Inlined here so users can copy-paste the entire filter menu without external dependencies\n */\n\ntype FacetedValue<Multiple extends boolean> = Multiple extends true\n  ? string[]\n  : string\n\ninterface FacetedContextValue<Multiple extends boolean = boolean> {\n  value?: FacetedValue<Multiple>\n  onItemSelect?: (value: string) => void\n  multiple?: Multiple\n}\n\nconst FacetedContext = React.createContext<FacetedContextValue<boolean> | null>(\n  null,\n)\n\nfunction useFacetedContext(name: string) {\n  const context = React.useContext(FacetedContext)\n  if (!context) {\n    throw new Error(`\\`${name}\\` must be within Faceted`)\n  }\n  return context\n}\n\ninterface FacetedProps<\n  Multiple extends boolean = false,\n> extends React.ComponentProps<typeof Popover> {\n  value?: FacetedValue<Multiple>\n  onValueChange?: (value: FacetedValue<Multiple> | undefined) => void\n  children?: React.ReactNode\n  multiple?: Multiple\n}\n\nfunction Faceted<Multiple extends boolean = false>(\n  props: FacetedProps<Multiple>,\n) {\n  const {\n    open: openProp,\n    onOpenChange: onOpenChangeProp,\n    value,\n    onValueChange,\n    children,\n    multiple = false,\n    ...facetedProps\n  } = props\n\n  const [uncontrolledOpen, setUncontrolledOpen] = React.useState(false)\n  const isControlled = openProp !== undefined\n  const open = isControlled ? openProp : uncontrolledOpen\n\n  const onOpenChange = React.useCallback(\n    (newOpen: boolean) => {\n      if (!isControlled) {\n        setUncontrolledOpen(newOpen)\n      }\n      onOpenChangeProp?.(newOpen)\n    },\n    [isControlled, onOpenChangeProp],\n  )\n\n  const onItemSelect = React.useCallback(\n    (selectedValue: string) => {\n      if (!onValueChange) return\n\n      if (multiple) {\n        const currentValue = (Array.isArray(value) ? value : []) as string[]\n        const newValue = currentValue.includes(selectedValue)\n          ? currentValue.filter(v => v !== selectedValue)\n          : [...currentValue, selectedValue]\n        onValueChange(newValue as FacetedValue<Multiple>)\n      } else {\n        if (value === selectedValue) {\n          onValueChange(undefined)\n        } else {\n          onValueChange(selectedValue as FacetedValue<Multiple>)\n        }\n\n        requestAnimationFrame(() => onOpenChange(false))\n      }\n    },\n    [multiple, value, onValueChange, onOpenChange],\n  )\n\n  const contextValue = React.useMemo<FacetedContextValue<typeof multiple>>(\n    () => ({ value, onItemSelect, multiple }),\n    [value, onItemSelect, multiple],\n  )\n\n  return (\n    <FacetedContext.Provider value={contextValue}>\n      <Popover open={open} onOpenChange={onOpenChange} {...facetedProps}>\n        {children}\n      </Popover>\n    </FacetedContext.Provider>\n  )\n}\n\nfunction FacetedTrigger(props: React.ComponentProps<typeof PopoverTrigger>) {\n  const { className, children, ...triggerProps } = props\n\n  return (\n    <PopoverTrigger\n      {...triggerProps}\n      className={cn(\"justify-between text-left\", className)}\n    >\n      {children}\n    </PopoverTrigger>\n  )\n}\n\ninterface FacetedBadgeListProps extends React.ComponentProps<\"div\"> {\n  options?: { label: string; value: string }[]\n  max?: number\n  badgeClassName?: string\n  placeholder?: string\n}\n\nfunction FacetedBadgeList(props: FacetedBadgeListProps) {\n  const {\n    options = [],\n    max = 2,\n    placeholder = \"Select options...\",\n    className,\n    badgeClassName,\n    ...badgeListProps\n  } = props\n\n  const context = useFacetedContext(\"FacetedBadgeList\")\n  const values = Array.isArray(context.value)\n    ? context.value\n    : ([context.value].filter(Boolean) as string[])\n\n  const getLabel = React.useCallback(\n    (value: string) => {\n      const option = options.find(opt => opt.value === value)\n      return option?.label ?? value\n    },\n    [options],\n  )\n\n  if (!values || values.length === 0) {\n    return (\n      <div\n        {...badgeListProps}\n        className=\"flex w-full items-center gap-1 text-muted-foreground\"\n      >\n        {placeholder}\n        <ChevronsUpDown className=\"ml-auto size-4 shrink-0 opacity-50\" />\n      </div>\n    )\n  }\n\n  return (\n    <div\n      {...badgeListProps}\n      className={cn(\"flex flex-wrap items-center gap-1\", className)}\n    >\n      {values.length > max ? (\n        <Badge\n          variant=\"secondary\"\n          className={cn(\"rounded-sm px-1 font-normal\", badgeClassName)}\n        >\n          {values.length} selected\n        </Badge>\n      ) : (\n        values.map(value => (\n          <Badge\n            key={value}\n            variant=\"secondary\"\n            className={cn(\"rounded-sm px-1 font-normal\", badgeClassName)}\n          >\n            <span className=\"truncate\">{getLabel(value)}</span>\n          </Badge>\n        ))\n      )}\n    </div>\n  )\n}\n\nfunction FacetedContent(props: React.ComponentProps<typeof PopoverContent>) {\n  const { className, children, ...contentProps } = props\n\n  return (\n    <PopoverContent\n      {...contentProps}\n      align=\"start\"\n      className={cn(\n        \"w-[200px] origin-(--radix-popover-content-transform-origin) p-0\",\n        className,\n      )}\n    >\n      <Command>{children}</Command>\n    </PopoverContent>\n  )\n}\n\nconst FacetedInput = CommandInput\n\nconst FacetedList = CommandList\n\nconst FacetedEmpty = CommandEmpty\n\nconst FacetedGroup = CommandGroup\n\ninterface FacetedItemProps extends React.ComponentProps<typeof CommandItem> {\n  value: string\n}\n\nfunction FacetedItem(props: FacetedItemProps) {\n  const { value, onSelect, className, children, ...itemProps } = props\n  const context = useFacetedContext(\"FacetedItem\")\n\n  const isSelected = context.multiple\n    ? Array.isArray(context.value) && context.value.includes(value)\n    : context.value === value\n\n  const onItemSelect = React.useCallback(\n    (currentValue: string) => {\n      if (onSelect) {\n        onSelect(currentValue)\n      } else if (context.onItemSelect) {\n        context.onItemSelect(currentValue)\n      }\n    },\n    [onSelect, context],\n  )\n\n  return (\n    <CommandItem\n      aria-selected={isSelected}\n      data-selected={isSelected}\n      className={cn(\"gap-2\", className)}\n      onSelect={() => onItemSelect(value)}\n      {...itemProps}\n    >\n      <span\n        className={cn(\n          \"flex size-4 items-center justify-center rounded-sm border border-primary\",\n          isSelected\n            ? \"bg-primary text-primary-foreground\"\n            : \"opacity-50 [&_svg]:invisible\",\n        )}\n      >\n        <Check className=\"size-4\" />\n      </span>\n      {children}\n    </CommandItem>\n  )\n}\n\n/**\n * Normalize join operators when filters are reordered\n *\n * This function ensures that filter order changes don't break the filter logic.\n * The joinOperator on each filter (except the first) determines how it joins\n * with the PREVIOUS filter in the array. When filters are reordered, we need\n * to preserve the logical relationship.\n *\n * Strategy:\n * 1. First filter always has joinOperator=\"and\" (it's ignored anyway)\n * 2. For each subsequent filter, determine the joinOperator based on:\n *    - If the current filter and previous filter were adjacent in original order,\n *      use the joinOperator that was on the current filter in original order\n *    - If they were not adjacent, trace the path between them in original order\n *      to determine the relationship\n *\n * Example:\n * Original: [A(and), B(or), C(and)]\n *   Logic: A OR B AND C → (A OR B) AND C (AND has precedence)\n * After swapping A and B: [B(and), A(?), C(?)]\n *   We want to preserve: (B OR A) AND C\n *   So: [B(and), A(or), C(and)]\n *\n * ROBUSTNESS:\n * This function uses filter properties (id, operator, variant, value) to match\n * filters, not just filterId. This means it will work even if filterId is\n * changed in the URL, as long as the filter properties remain the same.\n *\n * @param originalFilters - Filters in their original order\n * @param reorderedFilters - Filters in their new order\n * @returns Normalized filters with correct joinOperator values\n */\nfunction normalizeFilterJoinOperators<TData>(\n  originalFilters: ExtendedColumnFilter<TData>[],\n  reorderedFilters: ExtendedColumnFilter<TData>[],\n): ExtendedColumnFilter<TData>[] {\n  // If filters are the same or empty, return as-is\n  if (\n    originalFilters.length === 0 ||\n    reorderedFilters.length === 0 ||\n    originalFilters.length !== reorderedFilters.length\n  ) {\n    return reorderedFilters\n  }\n\n  // Check if order actually changed (using filterId first, then fallback to properties)\n  const orderChangedById = reorderedFilters.some(\n    (filter, index) => filter.filterId !== originalFilters[index]?.filterId,\n  )\n\n  // Also check if order changed by comparing filter properties\n  const orderChangedByProps = reorderedFilters.some((filter, index) => {\n    const original = originalFilters[index]\n    if (!original) return true\n    return getFilterKey(filter) !== getFilterKey(original)\n  })\n\n  if (!orderChangedById && !orderChangedByProps) {\n    return reorderedFilters\n  }\n\n  // Create maps using filterId (primary) and filter properties (fallback)\n  // This allows matching even if filterId is changed in URL\n  const originalIndexMapById = new Map<string, number>()\n  const originalIndexMapByKey = new Map<string, number>()\n\n  originalFilters.forEach((filter, index) => {\n    originalIndexMapById.set(filter.filterId, index)\n    originalIndexMapByKey.set(getFilterKey(filter), index)\n  })\n\n  // Normalize the reordered filters\n  return reorderedFilters.map((filter, newIndex) => {\n    // First filter always has \"and\" (it's ignored in evaluation anyway)\n    if (newIndex === 0) {\n      return {\n        ...filter,\n        joinOperator: JOIN_OPERATORS.AND,\n      }\n    }\n\n    // Get the previous filter in the new order\n    const previousFilter = reorderedFilters[newIndex - 1]\n\n    // Try to find original index using filterId first, then fallback to properties\n    let currentOriginalIndex = originalIndexMapById.get(filter.filterId) ?? -1\n    let previousOriginalIndex =\n      originalIndexMapById.get(previousFilter.filterId) ?? -1\n\n    // If not found by filterId, try matching by properties\n    // This handles the case where filterId was changed in the URL\n    if (currentOriginalIndex === -1) {\n      currentOriginalIndex =\n        originalIndexMapByKey.get(getFilterKey(filter)) ?? -1\n    }\n    if (previousOriginalIndex === -1) {\n      previousOriginalIndex =\n        originalIndexMapByKey.get(getFilterKey(previousFilter)) ?? -1\n    }\n\n    // If either filter wasn't in original, default to AND\n    // This can happen if filters were added/removed or properties changed\n    if (currentOriginalIndex === -1 || previousOriginalIndex === -1) {\n      return {\n        ...filter,\n        joinOperator: JOIN_OPERATORS.AND,\n      }\n    }\n\n    // If filters were adjacent in original order\n    if (Math.abs(currentOriginalIndex - previousOriginalIndex) === 1) {\n      // They were adjacent - use the joinOperator from the filter that came\n      // after the earlier one in original order\n      if (currentOriginalIndex > previousOriginalIndex) {\n        // Current came after previous in original - use current's original joinOperator\n        return {\n          ...filter,\n          joinOperator: originalFilters[currentOriginalIndex].joinOperator,\n        }\n      } else {\n        // Current came before previous in original - use previous's original joinOperator\n        // (which determines how it joins with what was before it)\n        return {\n          ...filter,\n          joinOperator: originalFilters[previousOriginalIndex].joinOperator,\n        }\n      }\n    }\n\n    // Filters were not adjacent in original order\n    // Determine relationship by checking if there's an OR operator in the path\n    const startIndex = Math.min(currentOriginalIndex, previousOriginalIndex)\n    const endIndex = Math.max(currentOriginalIndex, previousOriginalIndex)\n\n    // Check if any filter between them (or the one after start) has OR\n    const hasOrInPath = originalFilters\n      .slice(startIndex, endIndex + 1)\n      .some((f, idx) => {\n        // Check joinOperator of filters after startIndex\n        return idx > 0 && f.joinOperator === JOIN_OPERATORS.OR\n      })\n\n    return {\n      ...filter,\n      joinOperator: hasOrInPath ? JOIN_OPERATORS.OR : JOIN_OPERATORS.AND,\n    }\n  })\n}\n\n/**\n * Hook to initialize filters from table state (for URL restoration)\n * Replaces the initialization useEffect with derived state\n *\n * @description This hook runs ONCE on mount to extract initial filter state from:\n * 1. Controlled filters (if provided via props)\n * 2. Table's globalFilter (for OR logic filters)\n * 3. Table's columnFilters (for AND logic filters)\n *\n * @debug Check React DevTools > Components > useInitialFilters to see returned value\n */\nfunction useInitialFilters<TData>(\n  table: Table<TData>,\n  controlledFilters?: ExtendedColumnFilter<TData>[],\n): ExtendedColumnFilter<TData>[] {\n  // Derive initial filters from table state only once on mount\n  const initialFilters = React.useMemo(() => {\n    // If controlled, use controlled filters (normalize to ensure filterId exists)\n    if (controlledFilters) {\n      const normalized = normalizeFiltersFromUrl(controlledFilters)\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(\"[useInitialFilters] Using controlled filters:\", normalized)\n      }\n      return normalized\n    }\n\n    // Check if table has globalFilter with filters object (OR filters)\n    const globalFilter = table.getState().globalFilter\n    if (\n      globalFilter &&\n      typeof globalFilter === \"object\" &&\n      \"filters\" in globalFilter\n    ) {\n      const filterObj = globalFilter as {\n        filters: (FilterWithoutId<TData> | ExtendedColumnFilter<TData>)[]\n      }\n      const normalized = normalizeFiltersFromUrl(filterObj.filters)\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(\n          \"[useInitialFilters] Extracted from globalFilter:\",\n          normalized,\n        )\n      }\n      return normalized\n    }\n\n    // Otherwise check columnFilters (AND filters)\n    const columnFilters = table.getState().columnFilters\n    if (columnFilters && columnFilters.length > 0) {\n      const extractedFilters = columnFilters\n        .map(cf => cf.value)\n        .filter(\n          (v): v is FilterWithoutId<TData> | ExtendedColumnFilter<TData> =>\n            v !== null && typeof v === \"object\" && \"id\" in v,\n        )\n      if (extractedFilters.length > 0) {\n        const normalized = normalizeFiltersFromUrl(extractedFilters)\n        if (process.env.NODE_ENV === \"development\") {\n          console.log(\n            \"[useInitialFilters] Extracted from columnFilters:\",\n            normalized,\n          )\n        }\n        return normalized\n      }\n    }\n\n    if (process.env.NODE_ENV === \"development\") {\n      console.log(\"[useInitialFilters] No initial filters found\")\n    }\n    return []\n    // Only run once on mount - we don't want to reset when table state changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n\n  return initialFilters\n}\n\n/**\n * Hook to sync filters with table state - COLUMNFILTERS-ONLY ARCHITECTURE\n *\n * @description This hook uses ONLY columnFilters (not globalFilter) for all filtering:\n * - Stores individual filter objects in each column's filter value\n * - Each column uses the `extendedFilter` filterFn that respects filter operators\n * - For OR/MIXED logic: Still uses separate columnFilters per column, but table evaluates them\n * - In uncontrolled mode: updates table's columnFilters with all filters\n * - In controlled mode: only updates table.meta (parent handles table state)\n * - globalFilter remains FREE for other purposes (e.g., separate global search feature)\n *\n * @architecture\n * TanStack Table's columnFilters work like this:\n * - Multiple filters on SAME column → evaluated by that column's filterFn\n * - Multiple filters on DIFFERENT columns → combined with AND logic\n * - To achieve OR logic across columns, we need custom evaluation\n *\n * SOLUTION: Store filter metadata in table.meta and use it in a custom pre-filter\n *\n * @debug\n * - Check table.getState().columnFilters to see all filters\n * - Check table.options.meta.joinOperator to see current join logic\n * - globalFilter should remain empty/unused\n */\nfunction useSyncFiltersWithTable<TData>(\n  table: Table<TData>,\n  filters: ExtendedColumnFilter<TData>[],\n  isControlled: boolean,\n) {\n  // Track if we've done initial sync\n  const hasSyncedRef = React.useRef(false)\n\n  // Use core utility to process filters and determine logic\n  const filterLogic = React.useMemo(\n    () => processFiltersForLogic(filters),\n    [filters],\n  )\n\n  // Update table meta immediately (no effect needed, happens during render)\n  // This is safe because we're only mutating table.options.meta, not triggering re-renders\n  // Custom filter logic can read this meta to apply correct join operators\n  if (table.options.meta) {\n    // eslint-disable-next-line react-hooks/immutability\n    table.options.meta.hasIndividualJoinOperators = true\n    // eslint-disable-next-line react-hooks/immutability\n    table.options.meta.joinOperator = filterLogic.joinOperator\n  }\n\n  // Sync with table state only when filters change (and not in controlled mode)\n  React.useEffect(() => {\n    // Skip if controlled - parent handles table state\n    if (isControlled) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(\n          \"[useSyncFiltersWithTable] Controlled mode - skipping table sync\",\n        )\n      }\n      return\n    }\n\n    // Mark that we've synced at least once\n    hasSyncedRef.current = true\n\n    if (process.env.NODE_ENV === \"development\") {\n      console.log(\"[useSyncFiltersWithTable] Syncing filters:\", {\n        filterCount: filters.length,\n        hasOrFilters: filterLogic.hasOrFilters,\n        hasSameColumnFilters: filterLogic.hasSameColumnFilters,\n        joinOperator: filterLogic.joinOperator,\n        filters: filters.map(f => ({\n          id: f.id,\n          operator: f.operator,\n          joinOp: f.joinOperator,\n          value: f.value,\n        })),\n      })\n    }\n\n    // Use core utility to determine routing\n    if (filterLogic.shouldUseGlobalFilter) {\n      table.resetColumnFilters()\n\n      table.setGlobalFilter({\n        filters: filterLogic.processedFilters,\n        joinOperator: filterLogic.joinOperator,\n      })\n\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(\n          \"[useSyncFiltersWithTable] Set globalFilter (OR/MIXED logic)\",\n          {\n            hasOrFilters: filterLogic.hasOrFilters,\n            hasSameColumnFilters: filterLogic.hasSameColumnFilters,\n          },\n        )\n      }\n    } else {\n      // BUILD COLUMN FILTERS ARRAY\n      // Each filter becomes a separate columnFilter entry\n      // TanStack Table will AND them together by default, but we can override with custom logic\n      const columnFilters = filterLogic.processedFilters.map(filter => ({\n        id: filter.id,\n        value: {\n          operator: filter.operator,\n          value: filter.value,\n          id: filter.id,\n          filterId: filter.filterId,\n          joinOperator: filter.joinOperator,\n        },\n      }))\n\n      table.setColumnFilters(columnFilters)\n\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(\n          \"[useSyncFiltersWithTable] Set columnFilters (columnFilters-only architecture)\",\n          \"- pure AND logic\",\n        )\n      }\n    }\n  }, [filters, filterLogic, table, isControlled])\n}\n\ninterface TableFilterMenuProps<TData> extends React.ComponentProps<\n  typeof PopoverContent\n> {\n  table: Table<TData>\n  filters?: ExtendedColumnFilter<TData>[]\n  onFiltersChange?: (filters: ExtendedColumnFilter<TData>[] | null) => void\n  joinOperator?: JoinOperator\n  onJoinOperatorChange?: (operator: JoinOperator) => void\n}\n\nexport function TableFilterMenu<TData>({\n  table,\n  filters: controlledFilters,\n  onFiltersChange: controlledOnFiltersChange,\n  // Legacy properties ignored: joinOperator, onJoinOperatorChange - now uses individual joinOperators\n  ...props\n}: Omit<\n  TableFilterMenuProps<TData>,\n  \"joinOperator\" | \"onJoinOperatorChange\"\n> & {\n  joinOperator?: JoinOperator\n  onJoinOperatorChange?: (operator: JoinOperator) => void\n}) {\n  const id = React.useId()\n  const labelId = React.useId()\n  const descriptionId = React.useId()\n  const [open, setOpen] = React.useState(false)\n  const addButtonRef = React.useRef<HTMLButtonElement>(null)\n\n  // Initialize filters from table state (replaces initialization useEffect)\n  const initialFilters = useInitialFilters(table, controlledFilters)\n  const [internalFilters, setInternalFilters] = React.useState(initialFilters)\n\n  // Use controlled values if provided, otherwise use internal state\n  const filters = controlledFilters ?? internalFilters\n  const isControlled = Boolean(controlledFilters)\n\n  // Handler that works with both controlled and internal state\n  const onFiltersChange = React.useCallback(\n    (newFilters: ExtendedColumnFilter<TData>[] | null) => {\n      if (controlledOnFiltersChange) {\n        controlledOnFiltersChange(newFilters)\n      } else {\n        setInternalFilters(newFilters ?? [])\n      }\n    },\n    [controlledOnFiltersChange],\n  )\n\n  // Sync filters with table state (replaces sync useEffect)\n  useSyncFiltersWithTable(table, filters, isControlled)\n\n  // Legacy global join operator - replaced with individual join operators per filter\n  const onJoinOperatorChange = React.useCallback(() => {\n    // No-op: Individual join operators handle this functionality\n    console.warn(ERROR_MESSAGES.DEPRECATED_GLOBAL_JOIN_OPERATOR)\n  }, [])\n\n  const columns = React.useMemo(() => {\n    return table\n      .getAllColumns()\n      .filter(column => column.columnDef.enableColumnFilter)\n  }, [table])\n\n  const onFilterAdd = React.useCallback(() => {\n    const column = columns[0]\n\n    if (!column) return\n\n    const filterWithoutId = {\n      id: column.id as Extract<keyof TData, string>,\n      value: \"\",\n      variant: column.columnDef.meta?.variant ?? FILTER_VARIANTS.TEXT,\n      operator: getDefaultFilterOperator(\n        column.columnDef.meta?.variant ?? FILTER_VARIANTS.TEXT,\n      ),\n      joinOperator: JOIN_OPERATORS.AND, // Default to AND for new filters\n    }\n\n    // Use current filter length as index to ensure unique IDs\n    const newFilterIndex = filters.length\n\n    onFiltersChange([\n      ...filters,\n      {\n        ...filterWithoutId,\n        filterId: createFilterId(filterWithoutId, newFilterIndex),\n      },\n    ])\n  }, [columns, filters, onFiltersChange])\n\n  const onFilterUpdate = React.useCallback(\n    (\n      filterId: string,\n      updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\n    ) => {\n      const updatedFilters = filters.map(filter => {\n        if (filter.filterId === filterId) {\n          return { ...filter, ...updates } as ExtendedColumnFilter<TData>\n        }\n        return filter\n      })\n      onFiltersChange(updatedFilters)\n    },\n    [filters, onFiltersChange],\n  )\n\n  const onFilterRemove = React.useCallback(\n    (filterId: string) => {\n      const updatedFilters = filters.filter(\n        filter => filter.filterId !== filterId,\n      )\n      onFiltersChange(updatedFilters)\n      requestAnimationFrame(() => {\n        addButtonRef.current?.focus()\n      })\n    },\n    [filters, onFiltersChange],\n  )\n\n  const onFiltersReset = React.useCallback(() => {\n    onFiltersChange(null)\n    onJoinOperatorChange?.() // Legacy - individual filters handle their own join operators\n  }, [onFiltersChange, onJoinOperatorChange])\n\n  // Toggle filter menu with 'F' key\n  useKeyboardShortcut({\n    key: KEYBOARD_SHORTCUTS.FILTER_TOGGLE,\n    onTrigger: () => setOpen(prev => !prev),\n  })\n\n  // Remove last filter with Shift+F\n  useKeyboardShortcut({\n    key: KEYBOARD_SHORTCUTS.FILTER_REMOVE,\n    requireShift: true,\n    onTrigger: () => {\n      if (filters.length > 0) {\n        onFilterRemove(filters[filters.length - 1]?.filterId ?? \"\")\n      }\n    },\n    condition: () => filters.length > 0,\n  })\n\n  // Handle filter reordering with join operator normalization\n  const handleFiltersReorder = React.useCallback(\n    (reorderedFilters: ExtendedColumnFilter<TData>[]) => {\n      // Normalize join operators when filters are reordered\n      const normalizedFilters = normalizeFilterJoinOperators(\n        filters,\n        reorderedFilters,\n      )\n      onFiltersChange(normalizedFilters)\n    },\n    [filters, onFiltersChange],\n  )\n\n  return (\n    <Sortable\n      value={filters}\n      onValueChange={handleFiltersReorder}\n      getItemValue={item => item.filterId}\n    >\n      <Popover open={open} onOpenChange={setOpen}>\n        <PopoverTrigger asChild>\n          <Button variant=\"outline\" size=\"sm\" title=\"Open filter menu (F)\">\n            <ListFilter />\n            Filter\n            {filters.length > 0 && (\n              <Badge\n                variant=\"secondary\"\n                className=\"h-[18.24px] rounded-[3.2px] px-[5.12px] font-mono text-[10.4px] font-normal\"\n              >\n                {filters.length}\n              </Badge>\n            )}\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent\n          aria-describedby={descriptionId}\n          aria-labelledby={labelId}\n          className=\"flex w-full max-w-(--radix-popover-content-available-width) origin-(--radix-popover-content-transform-origin) flex-col gap-3.5 p-4 sm:min-w-[380px]\"\n          {...props}\n        >\n          <div className=\"flex flex-col gap-1\">\n            <h4 id={labelId} className=\"leading-none font-medium\">\n              {filters.length > 0 ? \"Filters\" : \"No filters applied\"}\n            </h4>\n            <p\n              id={descriptionId}\n              className={cn(\n                \"text-sm text-muted-foreground\",\n                filters.length > 0 && \"sr-only\",\n              )}\n            >\n              {filters.length > 0\n                ? \"Modify filters to refine your rows.\"\n                : \"Add filters to refine your rows.\"}\n            </p>\n          </div>\n          {filters.length > 0 ? (\n            <SortableContent asChild>\n              <ul className=\"flex max-h-[300px] flex-col gap-2 overflow-y-auto p-1\">\n                {filters.map((filter, index) => (\n                  <TableFilterItem<TData>\n                    key={filter.filterId}\n                    filter={filter}\n                    index={index}\n                    filterItemId={`${id}-filter-${filter.filterId}`}\n                    columns={columns}\n                    onFilterUpdate={onFilterUpdate}\n                    onFilterRemove={onFilterRemove}\n                  />\n                ))}\n              </ul>\n            </SortableContent>\n          ) : null}\n          <div className=\"flex w-full items-center gap-2\">\n            <Button\n              size=\"sm\"\n              className=\"rounded\"\n              ref={addButtonRef}\n              onClick={onFilterAdd}\n              title=\"Add a new filter\"\n            >\n              Add filter\n            </Button>\n            {filters.length > 0 ? (\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                className=\"rounded\"\n                onClick={onFiltersReset}\n                title=\"Clear all filters\"\n              >\n                Reset filters\n              </Button>\n            ) : null}\n          </div>\n        </PopoverContent>\n      </Popover>\n      <SortableOverlay>\n        <div className=\"flex items-center gap-2\">\n          <div className=\"h-8 min-w-[72px] rounded-sm bg-primary/10\" />\n          <div className=\"h-8 w-32 rounded-sm bg-primary/10\" />\n          <div className=\"h-8 w-32 rounded-sm bg-primary/10\" />\n          <div className=\"h-8 min-w-36 flex-1 rounded-sm bg-primary/10\" />\n          <div className=\"size-8 shrink-0 rounded-sm bg-primary/10\" />\n          <div className=\"size-8 shrink-0 rounded-sm bg-primary/10\" />\n        </div>\n      </SortableOverlay>\n    </Sortable>\n  )\n}\n\ninterface TableFilterItemProps<TData> {\n  filter: ExtendedColumnFilter<TData>\n  index: number\n  filterItemId: string\n  columns: Column<TData>[]\n  onFilterUpdate: (\n    filterId: string,\n    updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\n  ) => void\n  onFilterRemove: (filterId: string) => void\n}\n\nfunction TableFilterItem<TData>({\n  filter,\n  index,\n  filterItemId,\n  columns,\n  onFilterUpdate,\n  onFilterRemove,\n}: TableFilterItemProps<TData>) {\n  const [showFieldSelector, setShowFieldSelector] = React.useState(false)\n  const [showOperatorSelector, setShowOperatorSelector] = React.useState(false)\n  const [showValueSelector, setShowValueSelector] = React.useState(false)\n\n  const column = columns.find(column => column.id === filter.id)\n  const inputId = `${filterItemId}-input`\n  const columnMeta = column?.columnDef.meta\n\n  // Handle keyboard shortcuts for removing filters\n  const onItemKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLLIElement>) => {\n      if (\n        event.target instanceof HTMLInputElement ||\n        event.target instanceof HTMLTextAreaElement\n      ) {\n        return\n      }\n\n      if (showFieldSelector || showOperatorSelector || showValueSelector) {\n        return\n      }\n\n      const key = event.key.toLowerCase()\n      if (\n        key === KEYBOARD_SHORTCUTS.BACKSPACE ||\n        key === KEYBOARD_SHORTCUTS.DELETE\n      ) {\n        event.preventDefault()\n        onFilterRemove(filter.filterId)\n      }\n    },\n    [\n      filter.filterId,\n      showFieldSelector,\n      showOperatorSelector,\n      showValueSelector,\n      onFilterRemove,\n    ],\n  )\n\n  if (!column) return null\n\n  return (\n    <SortableItem value={filter.filterId} asChild>\n      <li\n        id={filterItemId}\n        tabIndex={-1}\n        className=\"flex items-center gap-2\"\n        onKeyDown={onItemKeyDown}\n      >\n        {/* Join operator (AND/OR) or \"Where\" for first filter */}\n        <FilterJoinOperator\n          filter={filter}\n          index={index}\n          filterItemId={filterItemId}\n          onFilterUpdate={onFilterUpdate}\n        />\n\n        {/* Field selector */}\n        <FilterFieldSelector\n          filter={filter}\n          filterItemId={filterItemId}\n          columns={columns}\n          onFilterUpdate={onFilterUpdate}\n          showFieldSelector={showFieldSelector}\n          setShowFieldSelector={setShowFieldSelector}\n        />\n\n        {/* Operator selector (equals, contains, etc.) */}\n        <FilterOperatorSelector\n          filter={filter}\n          filterItemId={filterItemId}\n          onFilterUpdate={onFilterUpdate}\n          showOperatorSelector={showOperatorSelector}\n          setShowOperatorSelector={setShowOperatorSelector}\n        />\n\n        {/* Value input (text, number, select, date, etc.) */}\n        <div className=\"min-w-36 flex-1\">\n          <FilterValueInput\n            filter={filter}\n            inputId={inputId}\n            column={column}\n            columnMeta={columnMeta}\n            onFilterUpdate={onFilterUpdate}\n            showValueSelector={showValueSelector}\n            setShowValueSelector={setShowValueSelector}\n          />\n        </div>\n\n        {/* Remove button */}\n        <Button\n          aria-controls={filterItemId}\n          variant=\"outline\"\n          size=\"icon\"\n          className=\"size-8 rounded\"\n          onClick={() => onFilterRemove(filter.filterId)}\n          title=\"Remove filter\"\n        >\n          <Trash2 />\n        </Button>\n\n        {/* Drag handle */}\n        <SortableItemHandle asChild>\n          <Button\n            variant=\"outline\"\n            size=\"icon\"\n            className=\"size-8 rounded\"\n            title=\"Drag to reorder filters\"\n          >\n            <Grip />\n          </Button>\n        </SortableItemHandle>\n      </li>\n    </SortableItem>\n  )\n}\n\n/* ----------------------------- Filter Input Components ---------------------------- */\n\ninterface FilterInputProps<TData> {\n  filter: ExtendedColumnFilter<TData>\n  inputId: string\n  column: Column<TData>\n  columnMeta?: Column<TData>[\"columnDef\"][\"meta\"]\n  onFilterUpdate: (\n    filterId: string,\n    updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\n  ) => void\n  showValueSelector: boolean\n  setShowValueSelector: (value: boolean) => void\n}\n\n/**\n * Empty state filter input for isEmpty/isNotEmpty operators\n */\nfunction FilterEmptyInput<TData>({\n  inputId,\n  columnMeta,\n  filter,\n}: Pick<FilterInputProps<TData>, \"inputId\" | \"columnMeta\" | \"filter\">) {\n  return (\n    <div\n      id={inputId}\n      role=\"status\"\n      aria-label={`${columnMeta?.label} filter is ${\n        filter.operator === FILTER_OPERATORS.EMPTY ? \"empty\" : \"not empty\"\n      }`}\n      aria-live=\"polite\"\n      className=\"h-8 w-full rounded border bg-transparent dark:bg-input/30\"\n    />\n  )\n}\nFilterEmptyInput.displayName = \"FilterEmptyInput\"\n\n/**\n * Text or number input for text/number/range variants\n */\nfunction FilterTextNumberInput<TData>({\n  filter,\n  inputId,\n  columnMeta,\n  onFilterUpdate,\n}: Pick<\n  FilterInputProps<TData>,\n  \"filter\" | \"inputId\" | \"columnMeta\" | \"onFilterUpdate\"\n>) {\n  const isNumber =\n    filter.variant === FILTER_VARIANTS.NUMBER ||\n    filter.variant === FILTER_VARIANTS.RANGE\n\n  return (\n    <Input\n      id={inputId}\n      type={isNumber ? FILTER_VARIANTS.NUMBER : FILTER_VARIANTS.TEXT}\n      aria-label={`${columnMeta?.label} filter value`}\n      aria-describedby={`${inputId}-description`}\n      inputMode={isNumber ? \"numeric\" : undefined}\n      placeholder={columnMeta?.placeholder ?? \"Enter a value...\"}\n      className=\"h-8 w-full rounded\"\n      value={typeof filter.value === \"string\" ? filter.value : \"\"}\n      onChange={event =>\n        onFilterUpdate(filter.filterId, {\n          value: String(event.target.value),\n        })\n      }\n    />\n  )\n}\nFilterTextNumberInput.displayName = \"FilterTextNumberInput\"\n\n/**\n * Boolean select input\n */\nfunction FilterBooleanSelect<TData>({\n  filter,\n  inputId,\n  columnMeta,\n  onFilterUpdate,\n  showValueSelector,\n  setShowValueSelector,\n}: FilterInputProps<TData>) {\n  if (Array.isArray(filter.value)) return null\n\n  const inputListboxId = `${inputId}-listbox`\n\n  return (\n    <Select\n      open={showValueSelector}\n      onOpenChange={setShowValueSelector}\n      value={filter.value}\n      onValueChange={value =>\n        onFilterUpdate(filter.filterId, {\n          value,\n        })\n      }\n    >\n      <SelectTrigger\n        id={inputId}\n        aria-controls={inputListboxId}\n        aria-label={`${columnMeta?.label} boolean filter`}\n        size=\"sm\"\n        className=\"w-full rounded\"\n      >\n        <SelectValue placeholder={filter.value ? \"True\" : \"False\"} />\n      </SelectTrigger>\n      <SelectContent id={inputListboxId}>\n        <SelectItem value=\"true\">True</SelectItem>\n        <SelectItem value=\"false\">False</SelectItem>\n      </SelectContent>\n    </Select>\n  )\n}\nFilterBooleanSelect.displayName = \"FilterBooleanSelect\"\n\n/**\n * Select/multi-select faceted input\n */\nfunction FilterFacetedSelect<TData>({\n  filter,\n  inputId,\n  columnMeta,\n  onFilterUpdate,\n  showValueSelector,\n  setShowValueSelector,\n}: FilterInputProps<TData>) {\n  const inputListboxId = `${inputId}-listbox`\n  const multiple = filter.variant === FILTER_VARIANTS.MULTI_SELECT\n  const selectedValues = multiple\n    ? Array.isArray(filter.value)\n      ? filter.value\n      : []\n    : typeof filter.value === \"string\"\n      ? filter.value\n      : undefined\n\n  return (\n    <Faceted\n      open={showValueSelector}\n      onOpenChange={setShowValueSelector}\n      value={selectedValues}\n      onValueChange={value => {\n        onFilterUpdate(filter.filterId, {\n          value,\n        })\n      }}\n      multiple={multiple}\n    >\n      <FacetedTrigger asChild>\n        <Button\n          id={inputId}\n          aria-controls={inputListboxId}\n          aria-label={`${columnMeta?.label} filter value${multiple ? \"s\" : \"\"}`}\n          variant=\"outline\"\n          size=\"sm\"\n          className=\"w-full rounded font-normal\"\n          title={`Select ${columnMeta?.label?.toLowerCase() ?? \"option\"}${multiple ? \"s\" : \"\"}`}\n        >\n          <FacetedBadgeList\n            options={columnMeta?.options}\n            placeholder={\n              columnMeta?.placeholder ??\n              `Select option${multiple ? \"s\" : \"\"}...`\n            }\n          />\n        </Button>\n      </FacetedTrigger>\n      <FacetedContent\n        id={inputListboxId}\n        className=\"w-[200px] origin-(--radix-popover-content-transform-origin)\"\n      >\n        <FacetedInput\n          aria-label={`Search ${columnMeta?.label} options`}\n          placeholder={columnMeta?.placeholder ?? \"Search options...\"}\n        />\n        <FacetedList>\n          <FacetedEmpty>No options found.</FacetedEmpty>\n          <FacetedGroup>\n            {columnMeta?.options?.map((option: Option) => (\n              <FacetedItem key={option.value} value={option.value}>\n                {option.icon && <option.icon />}\n                <span>{option.label}</span>\n                {option.count && (\n                  <span className=\"ml-auto font-mono text-xs\">\n                    {option.count}\n                  </span>\n                )}\n              </FacetedItem>\n            ))}\n          </FacetedGroup>\n        </FacetedList>\n      </FacetedContent>\n    </Faceted>\n  )\n}\n\n/**\n * Date picker input for date/dateRange variants\n */\nfunction FilterDatePicker<TData>({\n  filter,\n  inputId,\n  columnMeta,\n  onFilterUpdate,\n  showValueSelector,\n  setShowValueSelector,\n}: FilterInputProps<TData>) {\n  const inputListboxId = `${inputId}-listbox`\n\n  const dateValue = Array.isArray(filter.value)\n    ? filter.value.filter(Boolean)\n    : [filter.value, filter.value].filter(Boolean)\n\n  const displayValue =\n    filter.operator === FILTER_OPERATORS.BETWEEN && dateValue.length === 2\n      ? `${formatDate(new Date(Number(dateValue[0])))} - ${formatDate(\n          new Date(Number(dateValue[1])),\n        )}`\n      : dateValue[0]\n        ? formatDate(new Date(Number(dateValue[0])))\n        : \"Pick a date\"\n\n  return (\n    <Popover open={showValueSelector} onOpenChange={setShowValueSelector}>\n      <PopoverTrigger asChild>\n        <Button\n          id={inputId}\n          aria-controls={inputListboxId}\n          aria-label={`${columnMeta?.label} date filter`}\n          variant=\"outline\"\n          size=\"sm\"\n          className={cn(\n            \"w-full justify-start rounded text-left font-normal\",\n            !filter.value && \"text-muted-foreground\",\n          )}\n          title={`Select ${columnMeta?.label?.toLowerCase() ?? FILTER_VARIANTS.DATE}${filter.operator === FILTER_OPERATORS.BETWEEN ? \" range\" : \"\"}`}\n        >\n          <CalendarIcon />\n          <span className=\"truncate\">{displayValue}</span>\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        id={inputListboxId}\n        align=\"start\"\n        className=\"w-auto origin-(--radix-popover-content-transform-origin) p-0\"\n      >\n        {filter.operator === FILTER_OPERATORS.BETWEEN ? (\n          <Calendar\n            aria-label={`Select ${columnMeta?.label} date range`}\n            mode={FILTER_VARIANTS.RANGE}\n            captionLayout=\"dropdown\"\n            selected={\n              dateValue.length === 2\n                ? {\n                    from: new Date(Number(dateValue[0])),\n                    to: new Date(Number(dateValue[1])),\n                  }\n                : {\n                    from: new Date(),\n                    to: new Date(),\n                  }\n            }\n            onSelect={date => {\n              onFilterUpdate(filter.filterId, {\n                value: date\n                  ? [\n                      (date.from?.getTime() ?? \"\").toString(),\n                      (date.to?.getTime() ?? \"\").toString(),\n                    ]\n                  : [],\n              })\n            }}\n          />\n        ) : (\n          <Calendar\n            aria-label={`Select ${columnMeta?.label} date`}\n            mode=\"single\"\n            captionLayout=\"dropdown\"\n            selected={dateValue[0] ? new Date(Number(dateValue[0])) : undefined}\n            onSelect={date => {\n              onFilterUpdate(filter.filterId, {\n                value: (date?.getTime() ?? \"\").toString(),\n              })\n            }}\n          />\n        )}\n      </PopoverContent>\n    </Popover>\n  )\n}\n\n/**\n * Main filter input renderer - delegates to specific input components\n */\nfunction FilterValueInput<TData>(props: FilterInputProps<TData>) {\n  const { filter, column, inputId, onFilterUpdate } = props\n\n  // Empty state for isEmpty/isNotEmpty operators\n  if (\n    filter.operator === FILTER_OPERATORS.EMPTY ||\n    filter.operator === FILTER_OPERATORS.NOT_EMPTY\n  ) {\n    return <FilterEmptyInput {...props} />\n  }\n\n  // Variant-specific inputs\n  switch (filter.variant) {\n    case FILTER_VARIANTS.TEXT:\n    case FILTER_VARIANTS.NUMBER:\n    case FILTER_VARIANTS.RANGE: {\n      // Range filter for isBetween operator\n      if (\n        (filter.variant === FILTER_VARIANTS.RANGE &&\n          filter.operator === FILTER_OPERATORS.BETWEEN) ||\n        filter.operator === FILTER_OPERATORS.BETWEEN\n      ) {\n        return (\n          <TableRangeFilter\n            filter={filter}\n            column={column}\n            inputId={inputId}\n            onFilterUpdate={onFilterUpdate}\n          />\n        )\n      }\n\n      return <FilterTextNumberInput {...props} />\n    }\n\n    case FILTER_VARIANTS.BOOLEAN:\n      return <FilterBooleanSelect {...props} />\n\n    case FILTER_VARIANTS.SELECT:\n    case FILTER_VARIANTS.MULTI_SELECT:\n      return <FilterFacetedSelect {...props} />\n\n    case FILTER_VARIANTS.DATE:\n    case FILTER_VARIANTS.DATE_RANGE:\n      return <FilterDatePicker {...props} />\n\n    default:\n      return null\n  }\n}\nFilterValueInput.displayName = \"FilterValueInput\"\nFilterFacetedSelect.displayName = \"FilterFacetedSelect\"\nFilterDatePicker.displayName = \"FilterDatePicker\"\n\n/* ----------------------- Filter Item Sub-Components ----------------------- */\n\n/**\n * Join operator selector (AND/OR) for filters after the first one\n */\nfunction FilterJoinOperator<TData>({\n  filter,\n  index,\n  filterItemId,\n  onFilterUpdate,\n}: {\n  filter: ExtendedColumnFilter<TData>\n  index: number\n  filterItemId: string\n  onFilterUpdate: (\n    filterId: string,\n    updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\n  ) => void\n}) {\n  const joinOperatorListboxId = `${filterItemId}-join-operator-listbox`\n\n  if (index === 0) {\n    return (\n      <div className=\"min-w-[72px] text-center\">\n        <span className=\"text-sm text-muted-foreground\">Where</span>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"min-w-[72px] text-center\">\n      <Select\n        value={filter.joinOperator || JOIN_OPERATORS.AND}\n        onValueChange={(value: JoinOperator) =>\n          onFilterUpdate(filter.filterId, { joinOperator: value })\n        }\n      >\n        <SelectTrigger\n          aria-label=\"Select join operator\"\n          aria-controls={joinOperatorListboxId}\n          size=\"sm\"\n          className=\"rounded lowercase\"\n        >\n          <SelectValue placeholder={filter.joinOperator || \"and\"} />\n        </SelectTrigger>\n        <SelectContent\n          id={joinOperatorListboxId}\n          position=\"popper\"\n          className=\"min-w-(--radix-select-trigger-width) lowercase\"\n        >\n          {dataTableConfig.joinOperators.map(operator => (\n            <SelectItem key={operator} value={operator}>\n              {operator}\n            </SelectItem>\n          ))}\n        </SelectContent>\n      </Select>\n    </div>\n  )\n}\nFilterJoinOperator.displayName = \"FilterJoinOperator\"\n\n/**\n * Field selector for choosing which column to filter\n */\nfunction FilterFieldSelector<TData>({\n  filter,\n  filterItemId,\n  columns,\n  onFilterUpdate,\n  showFieldSelector,\n  setShowFieldSelector,\n}: {\n  filter: ExtendedColumnFilter<TData>\n  filterItemId: string\n  columns: Column<TData>[]\n  onFilterUpdate: (\n    filterId: string,\n    updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\n  ) => void\n  showFieldSelector: boolean\n  setShowFieldSelector: (value: boolean) => void\n}) {\n  const fieldListboxId = `${filterItemId}-field-listbox`\n\n  return (\n    <Popover open={showFieldSelector} onOpenChange={setShowFieldSelector}>\n      <PopoverTrigger asChild>\n        <Button\n          aria-controls={fieldListboxId}\n          variant=\"outline\"\n          size=\"sm\"\n          className=\"w-32 justify-between rounded font-normal\"\n          title=\"Select field to filter\"\n        >\n          <span className=\"truncate\">\n            {columns.find(column => column.id === filter.id)?.columnDef.meta\n              ?.label ?? \"Select field\"}\n          </span>\n          <ChevronsUpDown className=\"opacity-50\" />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        id={fieldListboxId}\n        align=\"start\"\n        className=\"w-40 origin-(--radix-popover-content-transform-origin) p-0\"\n      >\n        <Command>\n          <CommandInput placeholder=\"Search fields...\" />\n          <CommandList>\n            <CommandEmpty>No fields found.</CommandEmpty>\n            <CommandGroup>\n              {columns.map(column => (\n                <CommandItem\n                  key={column.id}\n                  value={column.id}\n                  onSelect={value => {\n                    onFilterUpdate(filter.filterId, {\n                      id: value as Extract<keyof TData, string>,\n                      variant:\n                        column.columnDef.meta?.variant ?? FILTER_VARIANTS.TEXT,\n                      operator: getDefaultFilterOperator(\n                        column.columnDef.meta?.variant ?? FILTER_VARIANTS.TEXT,\n                      ),\n                      value: \"\",\n                    })\n\n                    setShowFieldSelector(false)\n                  }}\n                >\n                  <span className=\"truncate\">\n                    {column.columnDef.meta?.label}\n                  </span>\n                  <Check\n                    className={cn(\n                      \"ml-auto\",\n                      column.id === filter.id ? \"opacity-100\" : \"opacity-0\",\n                    )}\n                  />\n                </CommandItem>\n              ))}\n            </CommandGroup>\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  )\n}\nFilterFieldSelector.displayName = \"FilterFieldSelector\"\n\n/**\n * Operator selector for choosing filter operation (equals, contains, etc.)\n */\nfunction FilterOperatorSelector<TData>({\n  filter,\n  filterItemId,\n  onFilterUpdate,\n  showOperatorSelector,\n  setShowOperatorSelector,\n}: {\n  filter: ExtendedColumnFilter<TData>\n  filterItemId: string\n  onFilterUpdate: (\n    filterId: string,\n    updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\n  ) => void\n  showOperatorSelector: boolean\n  setShowOperatorSelector: (value: boolean) => void\n}) {\n  const operatorListboxId = `${filterItemId}-operator-listbox`\n  const filterOperators = getFilterOperators(filter.variant)\n\n  return (\n    <Select\n      open={showOperatorSelector}\n      onOpenChange={setShowOperatorSelector}\n      value={filter.operator}\n      onValueChange={(value: FilterOperator) =>\n        onFilterUpdate(filter.filterId, {\n          operator: value,\n          value:\n            value === FILTER_OPERATORS.EMPTY ||\n            value === FILTER_OPERATORS.NOT_EMPTY\n              ? \"\"\n              : filter.value,\n        })\n      }\n    >\n      <SelectTrigger\n        aria-controls={operatorListboxId}\n        size=\"sm\"\n        className=\"w-32 rounded lowercase\"\n      >\n        <div className=\"truncate\">\n          <SelectValue placeholder={filter.operator} />\n        </div>\n      </SelectTrigger>\n      <SelectContent\n        id={operatorListboxId}\n        className=\"origin-(--radix-select-content-transform-origin)\"\n      >\n        {filterOperators.map(operator => (\n          <SelectItem\n            key={operator.value}\n            value={operator.value}\n            className=\"lowercase\"\n          >\n            {operator.label}\n          </SelectItem>\n        ))}\n      </SelectContent>\n    </Select>\n  )\n}\nFilterOperatorSelector.displayName = \"FilterOperatorSelector\"\n\n/* ----------------------------- Main Components ---------------------------- */\n\n// Add displayName to DataTableFilterItem for React DevTools\ninterface DataTableFilterItemType {\n  <TData>(props: TableFilterItemProps<TData>): React.JSX.Element | null\n  displayName?: string\n}\n\n;(TableFilterItem as DataTableFilterItemType).displayName =\n  \"DataTableFilterItem\"\n\n/**\n * @required displayName is required for auto feature detection\n * @see src/components/niko-table/config/feature-detection.ts\n */\nTableFilterMenu.displayName = \"TableFilterMenu\"\n",
      "type": "registry:component",
      "target": "components/niko-table/filters/table-filter-menu.tsx"
    },
    {
      "path": "src/components/niko-table/filters/table-range-filter.tsx",
      "content": "\"use client\"\n\n/**\n * Table range filter component\n * @description A range filter component for DataTable that allows users to filter data based on numerical ranges.\n */\n\nimport type { Column } from \"@tanstack/react-table\"\nimport * as React from \"react\"\n\nimport { Input } from \"@/components/ui/input\"\nimport { cn } from \"@/lib/utils\"\nimport type { ExtendedColumnFilter } from \"../types\"\n\ninterface TableRangeFilterProps<TData> extends React.ComponentProps<\"div\"> {\n  filter: ExtendedColumnFilter<TData>\n  column: Column<TData>\n  inputId: string\n  onFilterUpdate: (\n    filterId: string,\n    updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\n  ) => void\n}\n\nexport function TableRangeFilter<TData>({\n  filter,\n  column,\n  inputId,\n  onFilterUpdate,\n  className,\n  ...props\n}: TableRangeFilterProps<TData>) {\n  const meta = column.columnDef.meta\n\n  const [min, max] = React.useMemo(() => {\n    const range = column.columnDef.meta?.range\n    if (range) return range\n\n    const values = column.getFacetedMinMaxValues()\n    if (!values) return [0, 100]\n\n    return [values[0], values[1]]\n  }, [column])\n\n  const formatValue = React.useCallback(\n    (value: string | number | undefined) => {\n      if (value === undefined || value === \"\") return \"\"\n      const numValue = Number(value)\n      return Number.isNaN(numValue)\n        ? \"\"\n        : numValue.toLocaleString(undefined, {\n            maximumFractionDigits: 0,\n          })\n    },\n    [],\n  )\n\n  const value = React.useMemo(() => {\n    if (Array.isArray(filter.value)) return filter.value.map(formatValue)\n    return [formatValue(filter.value), \"\"]\n  }, [filter.value, formatValue])\n\n  const onRangeValueChange = React.useCallback(\n    (value: string | number, isMin?: boolean) => {\n      const numValue = Number(value)\n      const currentValues = Array.isArray(filter.value)\n        ? filter.value\n        : [\"\", \"\"]\n      const otherValue = isMin\n        ? (currentValues[1] ?? \"\")\n        : (currentValues[0] ?? \"\")\n\n      if (\n        value === \"\" ||\n        (!Number.isNaN(numValue) &&\n          (isMin\n            ? numValue >= min && numValue <= (Number(otherValue) || max)\n            : numValue <= max && numValue >= (Number(otherValue) || min)))\n      ) {\n        onFilterUpdate(filter.filterId, {\n          value: isMin\n            ? [String(value), String(otherValue)]\n            : [String(otherValue), String(value)],\n        })\n      }\n    },\n    [filter.filterId, filter.value, min, max, onFilterUpdate],\n  )\n\n  return (\n    <div\n      data-slot=\"range\"\n      className={cn(\"flex w-full items-center gap-2\", className)}\n      {...props}\n    >\n      <Input\n        id={`${inputId}-min`}\n        type=\"number\"\n        aria-label={`${meta?.label} minimum value`}\n        aria-valuemin={min}\n        aria-valuemax={max}\n        data-slot=\"range-min\"\n        inputMode=\"numeric\"\n        placeholder={min.toString()}\n        min={min}\n        max={max}\n        className=\"h-8 w-full rounded\"\n        defaultValue={value[0]}\n        onChange={event => onRangeValueChange(String(event.target.value), true)}\n      />\n      <span className=\"sr-only shrink-0 text-muted-foreground\">to</span>\n      <Input\n        id={`${inputId}-max`}\n        type=\"number\"\n        aria-label={`${meta?.label} maximum value`}\n        aria-valuemin={min}\n        aria-valuemax={max}\n        data-slot=\"range-max\"\n        inputMode=\"numeric\"\n        placeholder={max.toString()}\n        min={min}\n        max={max}\n        className=\"h-8 w-full rounded\"\n        defaultValue={value[1]}\n        onChange={event => onRangeValueChange(String(event.target.value))}\n      />\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/niko-table/filters/table-range-filter.tsx"
    }
  ],
  "type": "registry:component"
}