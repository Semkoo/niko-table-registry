{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-column-faceted-filter",
  "title": "DataTable Column Faceted Filter",
  "description": "Column header faceted filter with multi-select options in a dropdown.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "https://niko-table.com/r/data-table.json",
    "https://niko-table.com/r/data-table-faceted-filter.json",
    "button",
    "dropdown-menu",
    "tooltip",
    "popover",
    "command"
  ],
  "files": [
    {
      "path": "src/components/niko-table/components/data-table-column-faceted-filter.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\nimport type { Column } from \"@tanstack/react-table\"\n\nimport {\n  TableColumnFacetedFilterOptions,\n  TableColumnFacetedFilterMenu,\n} from \"../filters/table-column-faceted-filter\"\nimport { useDataTable } from \"../core\"\nimport { useColumnHeaderContext } from \"./data-table-column-header\"\n\n/**\n * Faceted filter options for composing inside DataTableColumnActions using context.\n */\nexport function DataTableColumnFacetedFilterOptions<TData, TValue>(\n  props: Omit<\n    React.ComponentProps<typeof TableColumnFacetedFilterOptions>,\n    \"column\"\n  > & {\n    column?: Column<TData, TValue>\n  },\n) {\n  const context = useColumnHeaderContext<TData, TValue>(false)\n  const column = props.column || context?.column\n\n  if (!column) {\n    console.warn(\n      \"DataTableColumnFacetedFilterOptions must be used within DataTableColumnHeaderRoot or provided with a column prop\",\n    )\n    return null\n  }\n\n  return <TableColumnFacetedFilterOptions column={column} {...props} />\n}\n\nDataTableColumnFacetedFilterOptions.displayName =\n  \"DataTableColumnFacetedFilterOptions\"\n\n/**\n * Standalone faceted filter menu for column header using context.\n */\nexport function DataTableColumnFacetedFilterMenu<TData, TValue>(\n  props: Omit<\n    React.ComponentProps<typeof TableColumnFacetedFilterMenu>,\n    \"column\" | \"table\"\n  > & {\n    column?: Column<TData, TValue>\n  },\n) {\n  const context = useColumnHeaderContext<TData, TValue>(false)\n  const column = props.column || context?.column\n  const { table } = useDataTable<TData>()\n\n  if (!column) {\n    console.warn(\n      \"DataTableColumnFacetedFilterMenu must be used within DataTableColumnHeaderRoot or provided with a column prop\",\n    )\n    return null\n  }\n\n  return (\n    <TableColumnFacetedFilterMenu column={column} table={table} {...props} />\n  )\n}\n\nDataTableColumnFacetedFilterMenu.displayName =\n  \"DataTableColumnFacetedFilterMenu\"\n",
      "type": "registry:component",
      "target": "components/niko-table/components/data-table-column-faceted-filter.tsx"
    },
    {
      "path": "src/components/niko-table/filters/table-column-faceted-filter.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\nimport type { Column, Table } from \"@tanstack/react-table\"\nimport { CircleHelp, Filter, FilterX } from \"lucide-react\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  DropdownMenuSeparator,\n  DropdownMenuLabel,\n} from \"@/components/ui/dropdown-menu\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\nimport { cn } from \"@/lib/utils\"\nimport {\n  TableFacetedFilter,\n  TableFacetedFilterContent,\n  useTableFacetedFilter,\n} from \"./table-faceted-filter\"\nimport { useDerivedColumnTitle } from \"../hooks\"\nimport { useGeneratedOptionsForColumn } from \"../hooks/use-generated-options\"\nimport { formatLabel } from \"../lib/format\"\nimport type { Option } from \"../types\"\n\n/**\n * A standard filter trigger button (Funnel icon).\n */\nexport function TableColumnFilterTrigger<TData, TValue>({\n  column,\n  className,\n  ...props\n}: {\n  column: Column<TData, TValue>\n} & React.ComponentProps<typeof Button>) {\n  const isFiltered = column.getIsFiltered()\n\n  const Icon = isFiltered ? FilterX : Filter\n\n  return (\n    <Button\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn(\n        \"size-7 transition-opacity dark:text-muted-foreground\",\n        isFiltered && \"text-primary\",\n        className,\n      )}\n      {...props}\n    >\n      <Icon className=\"size-3.5\" />\n      <span className=\"sr-only\">Filter column</span>\n    </Button>\n  )\n}\n\n/**\n * Faceted filter options for composing inside TableColumnActions.\n * Renders as inline searchable menu with checkboxes.\n *\n * @example\n * ```tsx\n * // Inside TableColumnActions\n * <TableColumnActions column={column}>\n *   <TableColumnFacetedFilterOptions\n *     column={column}\n *     options={[{ label: \"Active\", value: \"active\" }]}\n *     multiple\n *   />\n * </TableColumnActions>\n * ```\n */\nexport function TableColumnFacetedFilterOptions<TData, TValue>({\n  column,\n  title,\n  options = [],\n  onValueChange,\n  multiple = true,\n  withSeparator = true,\n}: {\n  column: Column<TData, TValue>\n  title?: string\n  options?: Option[]\n  onValueChange?: (value: string[] | undefined) => void\n  /** Whether to allow multiple selections. Defaults to true. */\n  multiple?: boolean\n  /** Whether to render a separator before the options. Defaults to true. */\n  withSeparator?: boolean\n}) {\n  const { selectedValues, onItemSelect, onReset } = useTableFacetedFilter({\n    column: column as Column<TData, unknown>,\n    onValueChange,\n    multiple,\n  })\n\n  const derivedTitle = useDerivedColumnTitle(column, column.id, title)\n  const labelText = multiple ? \"Column Multi Select\" : \"Column Select\"\n  const tooltipText = multiple\n    ? \"Select multiple options to filter\"\n    : \"Select a single option to filter\"\n\n  return (\n    <>\n      {withSeparator && <DropdownMenuSeparator />}\n      <DropdownMenuLabel className=\"flex items-center justify-between text-xs font-normal text-muted-foreground\">\n        <span>{labelText}</span>\n        <Tooltip>\n          <TooltipTrigger asChild>\n            <CircleHelp className=\"size-3.5 cursor-help\" />\n          </TooltipTrigger>\n          <TooltipContent side=\"right\">\n            {tooltipText}\n            {derivedTitle && ` - ${derivedTitle}`}\n          </TooltipContent>\n        </Tooltip>\n      </DropdownMenuLabel>\n      <TableFacetedFilterContent\n        title={derivedTitle}\n        options={options}\n        selectedValues={selectedValues}\n        onItemSelect={onItemSelect}\n        onReset={onReset}\n      />\n    </>\n  )\n}\n\n/**\n * Standalone faceted filter menu for column headers.\n * Shows a filter button that opens a popover with filter options.\n *\n * @example\n * ```tsx\n * // Standalone usage\n * <TableColumnFacetedFilterMenu\n *   column={column}\n *   options={[{ label: \"Active\", value: \"active\" }]}\n * />\n * ```\n */\nexport function TableColumnFacetedFilterMenu<TData, TValue>({\n  column,\n  table,\n  title,\n  options,\n  onValueChange,\n  multiple,\n  limitToFilteredRows = true,\n  ...props\n}: Omit<\n  React.ComponentProps<typeof TableFacetedFilter>,\n  \"column\" | \"trigger\" | \"options\"\n> & {\n  column: Column<TData, TValue>\n  table?: Table<TData>\n  title?: string\n  options?: React.ComponentProps<typeof TableFacetedFilter>[\"options\"]\n  /**\n   * If true, only show options that exist in the currently filtered rows.\n   * If false, show all options from the entire dataset.\n   * @default true\n   */\n  limitToFilteredRows?: boolean\n}) {\n  const derivedTitle = useDerivedColumnTitle(column, column.id, title)\n\n  // Auto-generate options from column meta (works for select/multi_select variants)\n  const generatedOptions = useGeneratedOptionsForColumn(\n    table as Table<TData>,\n    column.id,\n    { limitToFilteredRows },\n  )\n\n  /**\n   * REACTIVITY FIX: Extract row model references outside memos so that when\n   * async data arrives, the new rows array reference triggers memo recomputation.\n   * Without this, `table` reference is stable across data changes and memos\n   * would return stale (empty) results after initial render with no data.\n   */\n  const coreRows = table?.getCoreRowModel().rows\n  const filteredRows = table?.getFilteredRowModel().rows\n\n  // Fallback: generate options from row data for any variant (text, boolean, etc.)\n  const fallbackOptions = React.useMemo((): Option[] => {\n    if (!table || !column) return []\n\n    const meta = column.columnDef.meta\n    const autoOptionsFormat =\n      (meta as Record<string, unknown>)?.autoOptionsFormat ?? true\n    const showCounts = (meta as Record<string, unknown>)?.showCounts ?? true\n\n    const rows = limitToFilteredRows ? filteredRows : coreRows\n    if (!rows) return []\n    const valueCounts = new Map<string, number>()\n\n    rows.forEach(row => {\n      const raw = row.getValue(column.id) as unknown\n      const values: unknown[] = Array.isArray(raw) ? raw : [raw]\n      values.forEach(v => {\n        if (v == null) return\n        const s = String(v)\n        if (!s) return\n        valueCounts.set(s, (valueCounts.get(s) || 0) + 1)\n      })\n    })\n\n    // If static options exist in meta with augment strategy, use them with counts\n    const metaOptions = (meta as Record<string, unknown>)?.options as\n      | Option[]\n      | undefined\n    const mergeStrategy = (meta as Record<string, unknown>)?.mergeStrategy as\n      | string\n      | undefined\n\n    if (metaOptions && metaOptions.length > 0 && mergeStrategy === \"augment\") {\n      return metaOptions.map(opt => ({\n        ...opt,\n        count: showCounts ? (valueCounts.get(opt.value) ?? 0) : undefined,\n      }))\n    }\n\n    if (metaOptions && metaOptions.length > 0) {\n      return metaOptions\n    }\n\n    return Array.from(valueCounts.entries())\n      .map(([value, count]) => ({\n        label: autoOptionsFormat ? formatLabel(value) : value,\n        value,\n        count: showCounts ? count : undefined,\n      }))\n      .sort((a, b) => a.label.localeCompare(b.label))\n  }, [table, column, limitToFilteredRows, coreRows, filteredRows])\n\n  const resolvedOptions =\n    options ??\n    (generatedOptions.length > 0 ? generatedOptions : fallbackOptions)\n\n  return (\n    <TableFacetedFilter\n      column={column}\n      title={derivedTitle}\n      options={resolvedOptions}\n      multiple={multiple}\n      onValueChange={onValueChange}\n      trigger={<TableColumnFilterTrigger column={column} />}\n      {...props}\n    />\n  )\n}\n\nTableColumnFacetedFilterOptions.displayName = \"TableColumnFacetedFilterOptions\"\nTableColumnFacetedFilterMenu.displayName = \"TableColumnFacetedFilterMenu\"\n",
      "type": "registry:component",
      "target": "components/niko-table/filters/table-column-faceted-filter.tsx"
    },
    {
      "path": "src/components/niko-table/components/data-table-column-filter-trigger.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\n\nimport { TableColumnFilterTrigger } from \"../filters/table-column-faceted-filter\"\nimport { useColumnHeaderContext } from \"./data-table-column-header\"\n\n/**\n * A standard filter trigger button (Funnel icon) using context.\n */\nexport function DataTableColumnFilterTrigger<TData, TValue>(\n  props: Omit<React.ComponentProps<typeof TableColumnFilterTrigger>, \"column\">,\n) {\n  const { column } = useColumnHeaderContext<TData, TValue>(true)\n  return <TableColumnFilterTrigger column={column} {...props} />\n}\n\nDataTableColumnFilterTrigger.displayName = \"DataTableColumnFilterTrigger\"\n",
      "type": "registry:component",
      "target": "components/niko-table/components/data-table-column-filter-trigger.tsx"
    }
  ],
  "type": "registry:component"
}