{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-row-dnd",
  "title": "DataTable Row DnD",
  "description": "Drag-and-drop row reordering with composable primitives. Includes DnD provider, draggable row, drag handle, and DnD-aware table body.",
  "dependencies": [
    "@dnd-kit/core",
    "@dnd-kit/modifiers",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities",
    "lucide-react"
  ],
  "registryDependencies": [
    "https://niko-table.com/r/data-table.json",
    "button"
  ],
  "files": [
    {
      "path": "src/components/niko-table/filters/table-row-dnd.tsx",
      "content": "\"use client\"\n\nimport React, { type CSSProperties } from \"react\"\nimport type { Table, Row } from \"@tanstack/react-table\"\nimport {\n  DndContext,\n  KeyboardSensor,\n  MouseSensor,\n  TouchSensor,\n  closestCenter,\n  type DragEndEvent,\n  type Modifier,\n  type UniqueIdentifier,\n  useSensor,\n  useSensors,\n} from \"@dnd-kit/core\"\nimport { restrictToVerticalAxis } from \"@dnd-kit/modifiers\"\nimport {\n  arrayMove,\n  SortableContext,\n  useSortable,\n  verticalListSortingStrategy,\n} from \"@dnd-kit/sortable\"\nimport { CSS } from \"@dnd-kit/utilities\"\nimport { GripVertical } from \"lucide-react\"\n\nimport { TableRow } from \"@/components/ui/table\"\nimport { Button } from \"@/components/ui/button\"\nimport { cn } from \"@/lib/utils\"\n\n// ============================================================================\n// TableRowDndProvider\n// ============================================================================\n\nexport interface TableRowDndProviderProps<TData> {\n  children: React.ReactNode\n  /** The table instance */\n  table: Table<TData>\n  /** The data array (needed for arrayMove reordering) */\n  data: TData[]\n  /** Callback when rows are reordered. Receives the new data array. */\n  onReorder: (data: TData[]) => void\n  /** DnD modifiers. Defaults to [restrictToVerticalAxis]. */\n  modifiers?: Modifier[]\n}\n\nexport function TableRowDndProvider<TData>({\n  children,\n  table,\n  data,\n  onReorder,\n  modifiers = [restrictToVerticalAxis],\n}: TableRowDndProviderProps<TData>) {\n  const rows = table.getRowModel().rows\n  const dataIds = React.useMemo<UniqueIdentifier[]>(\n    () => rows.map(row => row.id),\n    [rows],\n  )\n\n  const sensors = useSensors(\n    useSensor(MouseSensor, {}),\n    useSensor(TouchSensor, {}),\n    useSensor(KeyboardSensor, {}),\n  )\n\n  const handleDragEnd = React.useCallback(\n    (event: DragEndEvent) => {\n      const { active, over } = event\n      if (active && over && active.id !== over.id) {\n        const oldIndex = dataIds.indexOf(active.id)\n        const newIndex = dataIds.indexOf(over.id)\n        onReorder(arrayMove(data, oldIndex, newIndex))\n      }\n    },\n    [dataIds, data, onReorder],\n  )\n\n  return (\n    <DndContext\n      collisionDetection={closestCenter}\n      modifiers={modifiers}\n      onDragEnd={handleDragEnd}\n      sensors={sensors}\n    >\n      {children}\n    </DndContext>\n  )\n}\n\nTableRowDndProvider.displayName = \"TableRowDndProvider\"\n\n// ============================================================================\n// TableDraggableRow\n// ============================================================================\n\nexport interface TableDraggableRowProps<TData> {\n  /** The row instance from TanStack Table */\n  row: Row<TData>\n  children: React.ReactNode\n  className?: string\n}\n\nexport function TableDraggableRow<TData>({\n  row,\n  children,\n  className,\n}: TableDraggableRowProps<TData>) {\n  const { transform, transition, setNodeRef, isDragging } = useSortable({\n    id: row.id,\n  })\n\n  const style: CSSProperties = {\n    transform: CSS.Transform.toString(transform),\n    transition: transition,\n    opacity: isDragging ? 0.8 : 1,\n    zIndex: isDragging ? 1 : 0,\n    position: \"relative\",\n  }\n\n  return (\n    <TableRow\n      ref={setNodeRef}\n      style={style}\n      data-state={row.getIsSelected() && \"selected\"}\n      className={cn(isDragging && \"bg-muted/50\", className)}\n    >\n      {children}\n    </TableRow>\n  )\n}\n\nTableDraggableRow.displayName = \"TableDraggableRow\"\n\n// ============================================================================\n// TableRowDragHandle\n// ============================================================================\n\nexport interface TableRowDragHandleProps {\n  /** The row ID used for sortable identification */\n  rowId: string\n  className?: string\n}\n\nexport function TableRowDragHandle({\n  rowId,\n  className,\n}: TableRowDragHandleProps) {\n  const { attributes, listeners } = useSortable({\n    id: rowId,\n  })\n\n  return (\n    <Button\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn(\"size-8 cursor-grab active:cursor-grabbing\", className)}\n      {...attributes}\n      {...listeners}\n    >\n      <GripVertical className=\"size-4 text-muted-foreground\" />\n      <span className=\"sr-only\">Drag to reorder</span>\n    </Button>\n  )\n}\n\nTableRowDragHandle.displayName = \"TableRowDragHandle\"\n\n// Re-export for use in DataTableDndBody\nexport { SortableContext, verticalListSortingStrategy }\nexport type { UniqueIdentifier }\n",
      "type": "registry:component",
      "target": "components/niko-table/filters/table-row-dnd.tsx"
    },
    {
      "path": "src/components/niko-table/components/data-table-row-dnd.tsx",
      "content": "\"use client\"\n\nimport { useDataTable } from \"../core\"\nimport {\n  TableRowDndProvider,\n  type TableRowDndProviderProps,\n  TableDraggableRow,\n  type TableDraggableRowProps,\n  TableRowDragHandle,\n  type TableRowDragHandleProps,\n} from \"../filters/table-row-dnd\"\n\n// ============================================================================\n// DataTableRowDndProvider\n// ============================================================================\n\nexport type DataTableRowDndProviderProps<TData> = Omit<\n  TableRowDndProviderProps<TData>,\n  \"table\"\n>\n\n/**\n * Context-aware row DnD provider that automatically connects to the DataTable context.\n *\n * @example\n * <DataTableRoot data={data} columns={columns} getRowId={(row) => row.id}>\n *   <DataTableRowDndProvider data={data} onReorder={setData}>\n *     <DataTable>\n *       <DataTableHeader />\n *       <DataTableDndBody />\n *     </DataTable>\n *   </DataTableRowDndProvider>\n * </DataTableRoot>\n */\nexport function DataTableRowDndProvider<TData>(\n  props: DataTableRowDndProviderProps<TData>,\n) {\n  const { table } = useDataTable<TData>()\n  return <TableRowDndProvider<TData> table={table} {...props} />\n}\n\nDataTableRowDndProvider.displayName = \"DataTableRowDndProvider\"\n\n// ============================================================================\n// DataTableDraggableRow\n// ============================================================================\n\nexport type DataTableDraggableRowProps<TData> = TableDraggableRowProps<TData>\n\n/**\n * Context-aware draggable row component.\n *\n * @example\n * <DataTableDraggableRow row={row}>\n *   {row.getVisibleCells().map(cell => (\n *     <TableCell key={cell.id}>\n *       {flexRender(cell.column.columnDef.cell, cell.getContext())}\n *     </TableCell>\n *   ))}\n * </DataTableDraggableRow>\n */\nexport function DataTableDraggableRow<TData>(\n  props: DataTableDraggableRowProps<TData>,\n) {\n  return <TableDraggableRow<TData> {...props} />\n}\n\nDataTableDraggableRow.displayName = \"DataTableDraggableRow\"\n\n// ============================================================================\n// DataTableRowDragHandle\n// ============================================================================\n\nexport type DataTableRowDragHandleProps = TableRowDragHandleProps\n\n/**\n * Context-aware row drag handle button.\n *\n * @example - In column definition\n * {\n *   id: \"drag-handle\",\n *   size: 40,\n *   header: () => null,\n *   cell: ({ row }) => <DataTableRowDragHandle rowId={row.id} />,\n * }\n */\nexport function DataTableRowDragHandle(props: DataTableRowDragHandleProps) {\n  return <TableRowDragHandle {...props} />\n}\n\nDataTableRowDragHandle.displayName = \"DataTableRowDragHandle\"\n",
      "type": "registry:component",
      "target": "components/niko-table/components/data-table-row-dnd.tsx"
    },
    {
      "path": "src/components/niko-table/core/data-table-dnd-structure.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\nimport { cn } from \"@/lib/utils\"\nimport { useDataTable } from \"./data-table-context\"\nimport {\n  TableHeader,\n  TableRow,\n  TableBody,\n  TableCell,\n} from \"@/components/ui/table\"\nimport { flexRender } from \"@tanstack/react-table\"\nimport { DataTableColumnHeaderRoot } from \"../components/data-table-column-header\"\nimport { getCommonPinningStyles } from \"../lib/styles\"\nimport {\n  TableDraggableRow,\n  SortableContext,\n  verticalListSortingStrategy,\n  type UniqueIdentifier,\n} from \"../filters/table-row-dnd\"\nimport {\n  TableDraggableHeader,\n  TableDragAlongCell,\n} from \"../filters/table-column-dnd\"\n\n// ============================================================================\n// DataTableDndBody (Row DnD)\n// ============================================================================\n\nexport interface DataTableDndBodyProps<TData> {\n  children?: React.ReactNode\n  className?: string\n  onRowClick?: (row: TData) => void\n}\n\n/**\n * DnD-aware table body that renders rows as draggable items.\n * Drop-in replacement for DataTableBody when using row drag-and-drop.\n *\n * Must be wrapped in a DataTableRowDndProvider (or TableRowDndProvider).\n *\n * @example\n * <DataTableRowDndProvider data={data} onReorder={setData}>\n *   <DataTable>\n *     <DataTableHeader />\n *     <DataTableDndBody />\n *   </DataTable>\n * </DataTableRowDndProvider>\n */\nexport function DataTableDndBody<TData>({\n  children,\n  className,\n  onRowClick,\n}: DataTableDndBodyProps<TData>) {\n  const { table, isLoading } = useDataTable<TData>()\n  const { rows } = table.getRowModel()\n\n  const dataIds = React.useMemo<UniqueIdentifier[]>(\n    () => rows.map(row => row.id),\n    [rows],\n  )\n\n  return (\n    <TableBody className={className}>\n      {!isLoading && rows?.length ? (\n        <SortableContext items={dataIds} strategy={verticalListSortingStrategy}>\n          {rows.map(row => {\n            const isClickable = !!onRowClick\n            const isExpanded = row.getIsExpanded()\n\n            // Find if any column has expandedContent meta\n            const expandColumn = row\n              .getAllCells()\n              .find(cell => cell.column.columnDef.meta?.expandedContent)\n\n            return (\n              <React.Fragment key={row.id}>\n                <TableDraggableRow row={row}>\n                  {row.getVisibleCells().map(cell => {\n                    const size = cell.column.columnDef.size\n                    const cellStyle = {\n                      width: size ? `${size}px` : undefined,\n                      ...getCommonPinningStyles(cell.column, false),\n                    }\n\n                    return (\n                      <TableCell\n                        key={cell.id}\n                        style={cellStyle}\n                        onClick={\n                          isClickable\n                            ? event => {\n                                const target = event.target as HTMLElement\n                                const isInteractiveElement =\n                                  target.closest(\"button\") ||\n                                  target.closest(\"input\") ||\n                                  target.closest(\"a\") ||\n                                  target.closest('[role=\"button\"]') ||\n                                  target.closest('[role=\"checkbox\"]') ||\n                                  target.closest(\n                                    \"[data-radix-collection-item]\",\n                                  ) ||\n                                  target.closest('[data-slot=\"checkbox\"]') ||\n                                  target.tagName === \"INPUT\" ||\n                                  target.tagName === \"BUTTON\" ||\n                                  target.tagName === \"A\"\n\n                                if (!isInteractiveElement) {\n                                  onRowClick?.(row.original)\n                                }\n                              }\n                            : undefined\n                        }\n                        className={cn(\n                          isClickable && \"cursor-pointer\",\n                          cell.column.getIsPinned() &&\n                            \"bg-background group-hover:bg-muted/50 group-data-[state=selected]:bg-muted\",\n                        )}\n                      >\n                        {flexRender(\n                          cell.column.columnDef.cell,\n                          cell.getContext(),\n                        )}\n                      </TableCell>\n                    )\n                  })}\n                </TableDraggableRow>\n\n                {/* Expanded content row */}\n                {isExpanded && expandColumn && (\n                  <TableRow>\n                    <TableCell\n                      colSpan={row.getVisibleCells().length}\n                      className=\"p-0\"\n                    >\n                      {expandColumn.column.columnDef.meta?.expandedContent?.(\n                        row.original,\n                      )}\n                    </TableCell>\n                  </TableRow>\n                )}\n              </React.Fragment>\n            )\n          })}\n        </SortableContext>\n      ) : null}\n\n      {children}\n    </TableBody>\n  )\n}\n\nDataTableDndBody.displayName = \"DataTableDndBody\"\n\n// ============================================================================\n// DataTableDndHeader (Column DnD)\n// ============================================================================\n\nexport interface DataTableDndHeaderProps {\n  className?: string\n  /**\n   * Makes the header sticky at the top when scrolling.\n   * @default true\n   */\n  sticky?: boolean\n}\n\n/**\n * DnD-aware table header that renders column headers as draggable items.\n * Drop-in replacement for DataTableHeader when using column drag-and-drop.\n *\n * Must be wrapped in a DataTableColumnDndProvider (or TableColumnDndProvider).\n *\n * @example\n * <DataTableColumnDndProvider columnOrder={columnOrder} onColumnOrderChange={setColumnOrder}>\n *   <DataTable>\n *     <DataTableDndHeader />\n *     <DataTableDndColumnBody />\n *   </DataTable>\n * </DataTableColumnDndProvider>\n */\nexport const DataTableDndHeader = React.memo(function DataTableDndHeader({\n  className,\n  sticky = true,\n}: DataTableDndHeaderProps) {\n  const { table } = useDataTable()\n\n  const headerGroups = table?.getHeaderGroups() ?? []\n\n  if (headerGroups.length === 0) {\n    return null\n  }\n\n  return (\n    <TableHeader\n      className={cn(\n        sticky && \"sticky top-0 z-10 bg-background\",\n        sticky &&\n          \"after:absolute after:right-0 after:bottom-0 after:left-0 after:h-px after:bg-border\",\n        className,\n      )}\n    >\n      {headerGroups.map(headerGroup => (\n        <TableRow key={headerGroup.id}>\n          {headerGroup.headers.map(header => (\n            <TableDraggableHeader key={header.id} header={header}>\n              {header.isPlaceholder ? null : (\n                <DataTableColumnHeaderRoot column={header.column}>\n                  {flexRender(\n                    header.column.columnDef.header,\n                    header.getContext(),\n                  )}\n                </DataTableColumnHeaderRoot>\n              )}\n            </TableDraggableHeader>\n          ))}\n        </TableRow>\n      ))}\n    </TableHeader>\n  )\n})\n\nDataTableDndHeader.displayName = \"DataTableDndHeader\"\n\n// ============================================================================\n// DataTableDndColumnBody (Column DnD)\n// ============================================================================\n\nexport interface DataTableDndColumnBodyProps<TData> {\n  children?: React.ReactNode\n  className?: string\n  onRowClick?: (row: TData) => void\n}\n\n/**\n * DnD-aware table body for column drag-and-drop.\n * Each cell is wrapped with useSortable to follow column drag position.\n *\n * Must be wrapped in a DataTableColumnDndProvider (or TableColumnDndProvider).\n *\n * @example\n * <DataTableColumnDndProvider columnOrder={columnOrder} onColumnOrderChange={setColumnOrder}>\n *   <DataTable>\n *     <DataTableDndHeader />\n *     <DataTableDndColumnBody />\n *   </DataTable>\n * </DataTableColumnDndProvider>\n */\nexport function DataTableDndColumnBody<TData>({\n  children,\n  className,\n  onRowClick,\n}: DataTableDndColumnBodyProps<TData>) {\n  const { table, isLoading } = useDataTable<TData>()\n  const { rows } = table.getRowModel()\n\n  return (\n    <TableBody className={className}>\n      {!isLoading && rows?.length\n        ? rows.map(row => {\n            const isClickable = !!onRowClick\n\n            return (\n              <TableRow\n                key={row.id}\n                data-row-index={row?.index}\n                data-row-id={row?.id}\n                data-state={row.getIsSelected() && \"selected\"}\n                className={cn(isClickable && \"cursor-pointer\", \"group\")}\n              >\n                {row.getVisibleCells().map(cell => (\n                  <TableDragAlongCell key={cell.id} cell={cell}>\n                    {flexRender(cell.column.columnDef.cell, cell.getContext())}\n                  </TableDragAlongCell>\n                ))}\n              </TableRow>\n            )\n          })\n        : null}\n\n      {children}\n    </TableBody>\n  )\n}\n\nDataTableDndColumnBody.displayName = \"DataTableDndColumnBody\"\n",
      "type": "registry:component",
      "target": "components/niko-table/core/data-table-dnd-structure.tsx"
    },
    {
      "path": "src/components/niko-table/core/data-table-virtualized-dnd-structure.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\nimport { useVirtualizer } from \"@tanstack/react-virtual\"\nimport { flexRender } from \"@tanstack/react-table\"\nimport { cn } from \"@/lib/utils\"\nimport { useDataTable } from \"./data-table-context\"\nimport {\n  TableHeader,\n  TableRow,\n  TableBody,\n  TableCell,\n} from \"@/components/ui/table\"\nimport { DataTableColumnHeaderRoot } from \"../components/data-table-column-header\"\nimport { getCommonPinningStyles } from \"../lib/styles\"\nimport {\n  SortableContext,\n  verticalListSortingStrategy,\n  type UniqueIdentifier,\n} from \"../filters/table-row-dnd\"\nimport {\n  TableDraggableHeader,\n  TableDragAlongCell,\n} from \"../filters/table-column-dnd\"\nimport { useSortable } from \"@dnd-kit/sortable\"\nimport { CSS } from \"@dnd-kit/utilities\"\nimport type { ScrollEvent } from \"./data-table-virtualized-structure\"\n\n// ============================================================================\n// VirtualizedDraggableRow â€” internal row component for virtualized DnD\n// ============================================================================\n\ninterface VirtualizedDraggableRowProps {\n  children: React.ReactNode\n  rowId: string\n  className?: string\n}\n\nfunction VirtualizedDraggableRow({\n  children,\n  rowId,\n  className,\n}: VirtualizedDraggableRowProps) {\n  const { transform, transition, setNodeRef, isDragging } = useSortable({\n    id: rowId,\n  })\n\n  const style: React.CSSProperties = {\n    transform: CSS.Transform.toString(transform),\n    transition: transition,\n    opacity: isDragging ? 0.8 : 1,\n    zIndex: isDragging ? 1 : 0,\n    position: \"relative\",\n  }\n\n  return (\n    <TableRow\n      ref={setNodeRef}\n      style={style}\n      className={cn(\"flex w-full\", isDragging && \"bg-muted/50\", className)}\n    >\n      {children}\n    </TableRow>\n  )\n}\n\n// ============================================================================\n// DataTableVirtualizedDndBody (Row DnD + Virtualization)\n// ============================================================================\n\nexport interface DataTableVirtualizedDndBodyProps<TData> {\n  children?: React.ReactNode\n  estimateSize?: number\n  overscan?: number\n  className?: string\n  onScroll?: (event: ScrollEvent) => void\n  onScrolledTop?: () => void\n  onScrolledBottom?: () => void\n  scrollThreshold?: number\n  onRowClick?: (\n    row: TData,\n    event: React.MouseEvent<HTMLTableRowElement>,\n  ) => void\n}\n\n/**\n * Virtualized DnD-aware table body that combines row virtualization with\n * drag-and-drop reordering. Uses @tanstack/react-virtual for performance\n * and @dnd-kit/sortable for drag interactions.\n *\n * Must be wrapped in a DataTableRowDndProvider (or TableRowDndProvider).\n *\n * @example\n * <DataTableRowDndProvider data={data} onReorder={setData}>\n *   <DataTable height={400}>\n *     <DataTableVirtualizedHeader />\n *     <DataTableVirtualizedDndBody estimateSize={34} overscan={10} />\n *   </DataTable>\n * </DataTableRowDndProvider>\n */\nexport function DataTableVirtualizedDndBody<TData>({\n  children,\n  estimateSize = 34,\n  overscan = 20,\n  className,\n  onScroll,\n  onRowClick,\n  onScrolledTop,\n  onScrolledBottom,\n  scrollThreshold = 50,\n}: DataTableVirtualizedDndBodyProps<TData>) {\n  const { table } = useDataTable()\n  const { rows } = table.getRowModel()\n  const [scrollElement, setScrollElement] =\n    React.useState<HTMLDivElement | null>(null)\n\n  const parentRef = React.useCallback(\n    (node: HTMLTableSectionElement | null) => {\n      if (node !== null) {\n        const container = node.closest(\n          '[data-slot=\"table-container\"]',\n        ) as HTMLDivElement | null\n        setScrollElement(container)\n      }\n    },\n    [],\n  )\n\n  const rowVirtualizer = useVirtualizer({\n    count: rows.length,\n    getScrollElement: () => scrollElement,\n    estimateSize: () => estimateSize,\n    overscan,\n    enabled: !!scrollElement,\n    measureElement:\n      typeof window !== \"undefined\" &&\n      navigator.userAgent.indexOf(\"Firefox\") === -1\n        ? element => element?.getBoundingClientRect().height\n        : undefined,\n  })\n\n  const handleScrollTop = React.useCallback(() => {\n    onScrolledTop?.()\n  }, [onScrolledTop])\n\n  const handleScrollBottom = React.useCallback(() => {\n    onScrolledBottom?.()\n  }, [onScrolledBottom])\n\n  React.useEffect(() => {\n    if (!scrollElement || !onScroll) return\n\n    const handleScroll = (event: Event) => {\n      const element = event.currentTarget as HTMLDivElement\n      const { scrollHeight, scrollTop, clientHeight } = element\n\n      const isTop = scrollTop === 0\n      const isBottom = scrollHeight - scrollTop - clientHeight < scrollThreshold\n      const percentage =\n        scrollHeight - clientHeight > 0\n          ? (scrollTop / (scrollHeight - clientHeight)) * 100\n          : 0\n\n      onScroll({\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n        isTop,\n        isBottom,\n        percentage,\n      })\n\n      if (isTop) handleScrollTop()\n      if (isBottom) handleScrollBottom()\n    }\n\n    scrollElement.addEventListener(\"scroll\", handleScroll, { passive: true })\n    return () => scrollElement.removeEventListener(\"scroll\", handleScroll)\n  }, [\n    scrollElement,\n    onScroll,\n    handleScrollTop,\n    handleScrollBottom,\n    scrollThreshold,\n  ])\n\n  const dataIds = React.useMemo<UniqueIdentifier[]>(\n    () => rows.map(row => row.id),\n    [rows],\n  )\n\n  const virtualItems = rowVirtualizer.getVirtualItems()\n  const hasVirtualItems = virtualItems.length > 0\n\n  const topSpacerHeight = hasVirtualItems ? virtualItems[0].start : 0\n  const lastItem = hasVirtualItems\n    ? virtualItems[virtualItems.length - 1]\n    : null\n  const bottomSpacerHeight = lastItem\n    ? rowVirtualizer.getTotalSize() - lastItem.end\n    : 0\n\n  return (\n    <TableBody ref={parentRef} className={cn(\"block\", className)}>\n      <SortableContext items={dataIds} strategy={verticalListSortingStrategy}>\n        {/* Top spacer for virtual scrolling offset */}\n        {topSpacerHeight > 0 && (\n          <TableRow\n            style={{ height: `${topSpacerHeight}px`, display: \"block\" }}\n          />\n        )}\n\n        {/* Render visible rows as draggable */}\n        {virtualItems.map(virtualRow => {\n          const row = rows[virtualRow.index]\n          const isClickable = !!onRowClick\n          const isExpanded = row.getIsExpanded()\n\n          const expandColumn = row\n            .getAllCells()\n            .find(cell => cell.column.columnDef.meta?.expandedContent)\n\n          return (\n            <React.Fragment key={`${row.id}-${isExpanded}`}>\n              <VirtualizedDraggableRow rowId={row.id}>\n                {row.getVisibleCells().map(cell => {\n                  const size = cell.column.columnDef.size\n                  const cellStyle = {\n                    width: size ? `${size}px` : undefined,\n                    minHeight: `${estimateSize}px`,\n                    ...getCommonPinningStyles(cell.column, false),\n                  }\n\n                  return (\n                    <TableCell\n                      key={cell.id}\n                      className={cn(\n                        size ? \"\" : \"w-full\",\n                        \"flex items-center\",\n                        isClickable && \"cursor-pointer\",\n                        cell.column.getIsPinned() &&\n                          \"bg-background group-hover:bg-muted/50 group-data-[state=selected]:bg-muted\",\n                      )}\n                      style={cellStyle}\n                      onClick={\n                        isClickable\n                          ? event => {\n                              const target = event.target as HTMLElement\n                              const isInteractiveElement =\n                                target.closest(\"button\") ||\n                                target.closest(\"input\") ||\n                                target.closest(\"a\") ||\n                                target.closest('[role=\"button\"]') ||\n                                target.closest('[role=\"checkbox\"]') ||\n                                target.closest(\n                                  \"[data-radix-collection-item]\",\n                                ) ||\n                                target.closest('[data-slot=\"checkbox\"]') ||\n                                target.tagName === \"INPUT\" ||\n                                target.tagName === \"BUTTON\" ||\n                                target.tagName === \"A\"\n\n                              if (!isInteractiveElement) {\n                                onRowClick(\n                                  row.original as TData,\n                                  event as unknown as React.MouseEvent<HTMLTableRowElement>,\n                                )\n                              }\n                            }\n                          : undefined\n                      }\n                    >\n                      {flexRender(\n                        cell.column.columnDef.cell,\n                        cell.getContext(),\n                      )}\n                    </TableCell>\n                  )\n                })}\n              </VirtualizedDraggableRow>\n\n              {/* Expanded content row */}\n              {isExpanded && expandColumn && (\n                <TableRow className=\"flex w-full\">\n                  <TableCell\n                    colSpan={row.getVisibleCells().length}\n                    className=\"w-full p-0\"\n                  >\n                    {expandColumn.column.columnDef.meta?.expandedContent?.(\n                      row.original,\n                    )}\n                  </TableCell>\n                </TableRow>\n              )}\n            </React.Fragment>\n          )\n        })}\n\n        {/* Bottom spacer for remaining virtual height */}\n        {bottomSpacerHeight > 0 && (\n          <TableRow\n            style={{ height: `${bottomSpacerHeight}px`, display: \"block\" }}\n          />\n        )}\n      </SortableContext>\n\n      {/* Empty state and other children */}\n      {children}\n    </TableBody>\n  )\n}\n\nDataTableVirtualizedDndBody.displayName = \"DataTableVirtualizedDndBody\"\n\n// ============================================================================\n// DataTableVirtualizedDndHeader (Column DnD + Virtualization)\n// ============================================================================\n\nexport interface DataTableVirtualizedDndHeaderProps {\n  className?: string\n  /**\n   * Makes the header sticky at the top when scrolling.\n   * @default true\n   */\n  sticky?: boolean\n}\n\n/**\n * Virtualized DnD-aware table header for column drag-and-drop.\n * Uses flex layout matching the virtualized table structure.\n *\n * Must be wrapped in a DataTableColumnDndProvider (or TableColumnDndProvider).\n *\n * @example\n * <DataTableColumnDndProvider columnOrder={columnOrder} onColumnOrderChange={setColumnOrder}>\n *   <DataTable height={400}>\n *     <DataTableVirtualizedDndHeader />\n *     <DataTableVirtualizedDndColumnBody estimateSize={34} />\n *   </DataTable>\n * </DataTableColumnDndProvider>\n */\nexport const DataTableVirtualizedDndHeader = React.memo(\n  function DataTableVirtualizedDndHeader({\n    className,\n    sticky = true,\n  }: DataTableVirtualizedDndHeaderProps) {\n    const { table } = useDataTable()\n\n    const headerGroups = table?.getHeaderGroups() ?? []\n\n    if (headerGroups.length === 0) {\n      return null\n    }\n\n    return (\n      <TableHeader\n        className={cn(\n          \"block\",\n          sticky && \"sticky top-0 z-10 bg-background\",\n          className,\n        )}\n      >\n        {headerGroups.map(headerGroup => (\n          <TableRow key={headerGroup.id} className=\"flex w-full border-b\">\n            {headerGroup.headers.map(header => {\n              const size = header.column.columnDef.size\n\n              return (\n                <TableDraggableHeader key={header.id} header={header}>\n                  <div\n                    className={cn(size ? \"\" : \"w-full\", \"flex items-center\")}\n                    style={{\n                      width: size ? `${size}px` : undefined,\n                      ...getCommonPinningStyles(header.column, true),\n                    }}\n                  >\n                    {header.isPlaceholder ? null : (\n                      <DataTableColumnHeaderRoot column={header.column}>\n                        {flexRender(\n                          header.column.columnDef.header,\n                          header.getContext(),\n                        )}\n                      </DataTableColumnHeaderRoot>\n                    )}\n                  </div>\n                </TableDraggableHeader>\n              )\n            })}\n          </TableRow>\n        ))}\n      </TableHeader>\n    )\n  },\n)\n\nDataTableVirtualizedDndHeader.displayName = \"DataTableVirtualizedDndHeader\"\n\n// ============================================================================\n// DataTableVirtualizedDndColumnBody (Column DnD + Virtualization)\n// ============================================================================\n\nexport interface DataTableVirtualizedDndColumnBodyProps<TData> {\n  children?: React.ReactNode\n  estimateSize?: number\n  overscan?: number\n  className?: string\n  onScroll?: (event: ScrollEvent) => void\n  onScrolledTop?: () => void\n  onScrolledBottom?: () => void\n  scrollThreshold?: number\n  onRowClick?: (\n    row: TData,\n    event: React.MouseEvent<HTMLTableRowElement>,\n  ) => void\n}\n\n/**\n * Virtualized DnD-aware table body for column drag-and-drop.\n * Each cell follows column drag position using useSortable.\n *\n * Must be wrapped in a DataTableColumnDndProvider (or TableColumnDndProvider).\n *\n * @example\n * <DataTableColumnDndProvider columnOrder={columnOrder} onColumnOrderChange={setColumnOrder}>\n *   <DataTable height={400}>\n *     <DataTableVirtualizedDndHeader />\n *     <DataTableVirtualizedDndColumnBody estimateSize={34} />\n *   </DataTable>\n * </DataTableColumnDndProvider>\n */\nexport function DataTableVirtualizedDndColumnBody<TData>({\n  children,\n  estimateSize = 34,\n  overscan = 20,\n  className,\n  onScroll,\n  onRowClick,\n  onScrolledTop,\n  onScrolledBottom,\n  scrollThreshold = 50,\n}: DataTableVirtualizedDndColumnBodyProps<TData>) {\n  const { table } = useDataTable()\n  const { rows } = table.getRowModel()\n  const [scrollElement, setScrollElement] =\n    React.useState<HTMLDivElement | null>(null)\n\n  const parentRef = React.useCallback(\n    (node: HTMLTableSectionElement | null) => {\n      if (node !== null) {\n        const container = node.closest(\n          '[data-slot=\"table-container\"]',\n        ) as HTMLDivElement | null\n        setScrollElement(container)\n      }\n    },\n    [],\n  )\n\n  const rowVirtualizer = useVirtualizer({\n    count: rows.length,\n    getScrollElement: () => scrollElement,\n    estimateSize: () => estimateSize,\n    overscan,\n    enabled: !!scrollElement,\n    measureElement:\n      typeof window !== \"undefined\" &&\n      navigator.userAgent.indexOf(\"Firefox\") === -1\n        ? element => element?.getBoundingClientRect().height\n        : undefined,\n  })\n\n  const handleScrollTop = React.useCallback(() => {\n    onScrolledTop?.()\n  }, [onScrolledTop])\n\n  const handleScrollBottom = React.useCallback(() => {\n    onScrolledBottom?.()\n  }, [onScrolledBottom])\n\n  React.useEffect(() => {\n    if (!scrollElement || !onScroll) return\n\n    const handleScroll = (event: Event) => {\n      const element = event.currentTarget as HTMLDivElement\n      const { scrollHeight, scrollTop, clientHeight } = element\n\n      const isTop = scrollTop === 0\n      const isBottom = scrollHeight - scrollTop - clientHeight < scrollThreshold\n      const percentage =\n        scrollHeight - clientHeight > 0\n          ? (scrollTop / (scrollHeight - clientHeight)) * 100\n          : 0\n\n      onScroll({\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n        isTop,\n        isBottom,\n        percentage,\n      })\n\n      if (isTop) handleScrollTop()\n      if (isBottom) handleScrollBottom()\n    }\n\n    scrollElement.addEventListener(\"scroll\", handleScroll, { passive: true })\n    return () => scrollElement.removeEventListener(\"scroll\", handleScroll)\n  }, [\n    scrollElement,\n    onScroll,\n    handleScrollTop,\n    handleScrollBottom,\n    scrollThreshold,\n  ])\n\n  const virtualItems = rowVirtualizer.getVirtualItems()\n  const hasVirtualItems = virtualItems.length > 0\n\n  const topSpacerHeight = hasVirtualItems ? virtualItems[0].start : 0\n  const lastItem = hasVirtualItems\n    ? virtualItems[virtualItems.length - 1]\n    : null\n  const bottomSpacerHeight = lastItem\n    ? rowVirtualizer.getTotalSize() - lastItem.end\n    : 0\n\n  return (\n    <TableBody ref={parentRef} className={cn(\"block\", className)}>\n      {/* Top spacer for virtual scrolling offset */}\n      {topSpacerHeight > 0 && (\n        <TableRow\n          style={{ height: `${topSpacerHeight}px`, display: \"block\" }}\n        />\n      )}\n\n      {/* Render visible rows with drag-along cells */}\n      {virtualItems.map(virtualRow => {\n        const row = rows[virtualRow.index]\n        const isClickable = !!onRowClick\n\n        return (\n          <TableRow\n            key={row.id}\n            ref={node => {\n              if (node) {\n                rowVirtualizer.measureElement(node)\n              }\n            }}\n            data-index={virtualRow.index}\n            data-row-index={row?.index}\n            data-row-id={row?.id}\n            data-state={row.getIsSelected() && \"selected\"}\n            className={cn(\"group flex w-full\", isClickable && \"cursor-pointer\")}\n          >\n            {row.getVisibleCells().map(cell => (\n              <TableDragAlongCell key={cell.id} cell={cell}>\n                <div\n                  className={cn(\n                    cell.column.columnDef.size ? \"\" : \"w-full\",\n                    \"flex items-center\",\n                  )}\n                  style={{\n                    minHeight: `${estimateSize}px`,\n                  }}\n                >\n                  {flexRender(cell.column.columnDef.cell, cell.getContext())}\n                </div>\n              </TableDragAlongCell>\n            ))}\n          </TableRow>\n        )\n      })}\n\n      {/* Bottom spacer for remaining virtual height */}\n      {bottomSpacerHeight > 0 && (\n        <TableRow\n          style={{ height: `${bottomSpacerHeight}px`, display: \"block\" }}\n        />\n      )}\n\n      {/* Empty state and other children */}\n      {children}\n    </TableBody>\n  )\n}\n\nDataTableVirtualizedDndColumnBody.displayName =\n  \"DataTableVirtualizedDndColumnBody\"\n",
      "type": "registry:component",
      "target": "components/niko-table/core/data-table-virtualized-dnd-structure.tsx"
    }
  ],
  "type": "registry:component"
}