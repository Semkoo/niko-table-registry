{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-slider-filter",
  "title": "DataTable Slider Filter",
  "description": "Slider-based filter for numeric range filtering.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "https://niko-table.com/r/data-table.json",
    "button",
    "input",
    "label",
    "popover",
    "separator",
    "slider"
  ],
  "files": [
    {
      "path": "src/components/niko-table/components/data-table-slider-filter.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { useDataTable } from \"../core\"\nimport {\n  TableSliderFilter,\n  type TableSliderFilterProps,\n} from \"../filters/table-slider-filter\"\nimport { useDerivedColumnTitle } from \"../hooks/use-derived-column-title\"\nimport { FILTER_VARIANTS } from \"../lib/constants\"\n\ntype DataTableSliderFilterProps<TData> = Omit<\n  TableSliderFilterProps<TData>,\n  \"column\" | \"title\"\n> & {\n  /**\n   * The accessor key of the column to filter (matches column definition)\n   */\n  accessorKey: keyof TData & string\n  /**\n   * Optional title override (if not provided, will use column.meta.label)\n   */\n  title?: string\n}\n\n/**\n * A slider filter component that automatically connects to the DataTable context\n * and derives the title from column metadata.\n *\n * @example -  Auto-detect everything from column metadata and data\n * const columns: DataTableColumnDef[] = [{ accessorKey: \"price\",..., meta: { label: \"Price\", unit: \"$\", range: [0, 1000] } },...]\n * <DataTableSliderFilter accessorKey=\"price\" />\n *\n * @example - Custom range shorthand with unit\n * <DataTableSliderFilter\n *   accessorKey=\"price\"\n *   range={[0, 1000]}\n *   unit=\"$\"\n * />\n *\n * @example - Individual min/max control\n * <DataTableSliderFilter\n *   accessorKey=\"rating\"\n *   min={1}\n *   max={5}\n *   step={0.5}\n * />\n *\n * @example - Full manual control with custom title\n * <DataTableSliderFilter\n *   accessorKey=\"distance\"\n *   title=\"Distance Range\"\n *   range={[0, 100]}\n *   step={5}\n *   unit=\"km\"\n * />\n */\n\nexport function DataTableSliderFilter<TData>({\n  accessorKey,\n  title,\n  ...props\n}: DataTableSliderFilterProps<TData>) {\n  const { table } = useDataTable<TData>()\n  const column = table.getColumn(accessorKey as string)\n\n  const derivedTitle = useDerivedColumnTitle(column, String(accessorKey), title)\n\n  // Auto-set variant in column meta if not already set\n  // This allows the auto-filterFn to be applied based on variant\n  React.useMemo(() => {\n    if (!column) return\n    const meta = (column.columnDef.meta ||= {})\n    // Only set variant if not already set (respects manual configuration)\n    if (!meta.variant) {\n      meta.variant = FILTER_VARIANTS.RANGE\n    }\n  }, [column])\n\n  // Early return if column not found\n  if (!column) {\n    console.warn(\n      `Column with accessorKey \"${accessorKey}\" not found in table columns`,\n    )\n    return null\n  }\n\n  return <TableSliderFilter column={column} title={derivedTitle} {...props} />\n}\n\n/**\n * @required displayName is required for auto feature detection\n * @see \"feature-detection.ts\"\n */\n\nDataTableSliderFilter.displayName = \"DataTableSliderFilter\"\n",
      "type": "registry:component",
      "target": "components/niko-table/components/data-table-slider-filter.tsx"
    },
    {
      "path": "src/components/niko-table/filters/table-slider-filter.tsx",
      "content": "\"use client\"\n\n/**\n * Table slider filter component\n * @description A slider filter component for DataTable that allows users to filter numerical data within a specified range. It supports manual configuration of range, min/max values, step size, and unit labels.\n */\n\nimport type { Column } from \"@tanstack/react-table\"\nimport { PlusCircle, XCircle } from \"lucide-react\"\nimport * as React from \"react\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { Slider } from \"@/components/ui/slider\"\nimport { cn } from \"@/lib/utils\"\n\ninterface Range {\n  min: number\n  max: number\n}\n\ntype RangeValue = [number, number]\n\nfunction getIsValidRange(value: unknown): value is RangeValue {\n  return (\n    Array.isArray(value) &&\n    value.length === 2 &&\n    typeof value[0] === \"number\" &&\n    typeof value[1] === \"number\"\n  )\n}\n\nfunction parseValuesAsNumbers(value: unknown): RangeValue | undefined {\n  if (\n    Array.isArray(value) &&\n    value.length === 2 &&\n    value.every(\n      v => (typeof v === \"string\" || typeof v === \"number\") && !Number.isNaN(v),\n    )\n  ) {\n    return [Number(value[0]), Number(value[1])]\n  }\n\n  return undefined\n}\n\nexport interface TableSliderFilterProps<TData> {\n  column: Column<TData, unknown>\n  title?: string\n  /**\n   * Manual range [min, max] (overrides min/max props and column.meta.range)\n   */\n  range?: RangeValue\n  /**\n   * Manual minimum value (overrides column.meta.range and faceted values)\n   */\n  min?: number\n  /**\n   * Manual maximum value (overrides column.meta.range and faceted values)\n   */\n  max?: number\n  /**\n   * Manual step value for the slider\n   */\n  step?: number\n  /**\n   * Unit label to display (e.g., \"$\", \"kg\", \"km\")\n   */\n  unit?: string\n  onValueChange?: (value: [number, number] | undefined) => void\n}\n\nexport function TableSliderFilter<TData>({\n  column,\n  title,\n  range: manualRange,\n  min: manualMin,\n  max: manualMax,\n  step: manualStep,\n  unit: manualUnit,\n  onValueChange,\n}: TableSliderFilterProps<TData>) {\n  const id = React.useId()\n\n  const columnFilterValue = parseValuesAsNumbers(column.getFilterValue())\n\n  const defaultRange = column.columnDef.meta?.range\n  const unit = manualUnit ?? column.columnDef.meta?.unit\n  const label = title ?? column.columnDef.meta?.label ?? column.id\n\n  // Compute range values - memoized to avoid recalculation\n  // This is safe because we're not triggering state updates, just reading values\n  const { min, max, step } = React.useMemo<Range & { step: number }>(() => {\n    let minValue = 0\n    let maxValue = 100\n\n    // Priority 1: Manual range prop (highest priority)\n    if (manualRange && getIsValidRange(manualRange)) {\n      minValue = manualRange[0]\n      maxValue = manualRange[1]\n    }\n    // Priority 2: Manual min/max props\n    else if (manualMin != null && manualMax != null) {\n      minValue = manualMin\n      maxValue = manualMax\n    }\n    // Priority 3: Use explicit range from column metadata\n    else if (defaultRange && getIsValidRange(defaultRange)) {\n      minValue = defaultRange[0]\n      maxValue = defaultRange[1]\n    }\n    // Priority 4: Get min/max from faceted values\n    // This is safe in useMemo as long as we're not calling setFilterValue\n    else {\n      const facetedValues = column.getFacetedMinMaxValues()\n      if (facetedValues?.[0] != null && facetedValues?.[1] != null) {\n        minValue = Number(facetedValues[0])\n        maxValue = Number(facetedValues[1])\n      }\n    }\n\n    // Calculate appropriate step size based on range\n    const rangeSize = maxValue - minValue\n    const calculatedStep =\n      rangeSize <= 20\n        ? 1\n        : rangeSize <= 100\n          ? Math.ceil(rangeSize / 20)\n          : Math.ceil(rangeSize / 50)\n\n    return {\n      min: minValue,\n      max: maxValue,\n      step: manualStep ?? calculatedStep,\n    }\n  }, [column, defaultRange, manualRange, manualMin, manualMax, manualStep])\n\n  const range = React.useMemo((): RangeValue => {\n    return columnFilterValue ?? [min, max]\n  }, [columnFilterValue, min, max])\n\n  const formatValue = React.useCallback((value: number) => {\n    return value.toLocaleString(undefined, { maximumFractionDigits: 0 })\n  }, [])\n\n  const applyFilterValue = React.useCallback(\n    (value: [number, number] | undefined) => {\n      column.setFilterValue(value)\n      onValueChange?.(value)\n    },\n    [column, onValueChange],\n  )\n\n  const onRangeValueChange = React.useCallback(\n    (value: string | number, isMin?: boolean) => {\n      const numValue = Number(value)\n      const currentValues = range\n\n      if (value === \"\") {\n        // Allow empty value, don't update filter\n        return\n      }\n\n      if (\n        !Number.isNaN(numValue) &&\n        (isMin\n          ? numValue >= min && numValue <= currentValues[1]\n          : numValue <= max && numValue >= currentValues[0])\n      ) {\n        applyFilterValue(\n          isMin ? [numValue, currentValues[1]] : [currentValues[0], numValue],\n        )\n      }\n    },\n    [min, max, range, applyFilterValue],\n  )\n\n  const onSliderValueChange = React.useCallback(\n    (value: RangeValue) => {\n      if (Array.isArray(value) && value.length === 2) {\n        applyFilterValue(value)\n      }\n    },\n    [applyFilterValue],\n  )\n\n  const onReset = React.useCallback(\n    (event: React.MouseEvent) => {\n      if (event.target instanceof HTMLDivElement) {\n        event.stopPropagation()\n      }\n      applyFilterValue(undefined)\n    },\n    [applyFilterValue],\n  )\n\n  return (\n    <Popover>\n      <PopoverTrigger asChild>\n        <Button variant=\"outline\" size=\"sm\" className=\"border-dashed\">\n          {columnFilterValue ? (\n            <div\n              role=\"button\"\n              aria-label={`Clear ${label} filter`}\n              tabIndex={0}\n              className=\"rounded-sm opacity-70 transition-opacity hover:opacity-100 focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none\"\n              onClick={onReset}\n            >\n              <XCircle />\n            </div>\n          ) : (\n            <PlusCircle />\n          )}\n          <span>{label}</span>\n          {columnFilterValue ? (\n            <>\n              <Separator\n                orientation=\"vertical\"\n                className=\"mx-0.5 data-[orientation=vertical]:h-4\"\n              />\n              {formatValue(columnFilterValue[0])} -{\" \"}\n              {formatValue(columnFilterValue[1])}\n              {unit ? ` ${unit}` : \"\"}\n            </>\n          ) : null}\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent align=\"start\" className=\"flex w-auto flex-col gap-4\">\n        <div className=\"flex flex-col gap-3\">\n          <p className=\"leading-none font-medium peer-disabled:cursor-not-allowed peer-disabled:opacity-70\">\n            {label}\n          </p>\n          <div className=\"flex items-center gap-4\">\n            <Label htmlFor={`${id}-from`} className=\"sr-only\">\n              From\n            </Label>\n            <div className=\"relative\">\n              <Input\n                key={`${id}-from-${range[0]}`}\n                id={`${id}-from`}\n                type=\"number\"\n                aria-label={`${label} minimum value`}\n                aria-valuemin={min}\n                aria-valuemax={max}\n                inputMode=\"numeric\"\n                pattern=\"[0-9]*\"\n                placeholder={min.toString()}\n                min={min}\n                max={max}\n                defaultValue={range[0]}\n                onChange={event =>\n                  onRangeValueChange(String(event.target.value), true)\n                }\n                className={cn(\"h-8 w-24\", unit && \"pr-8\")}\n              />\n              {unit && (\n                <span className=\"absolute top-0 right-0 bottom-0 mt-0.5 mr-0.5 flex h-7 items-center rounded-r-md bg-accent px-2 text-sm text-muted-foreground\">\n                  {unit}\n                </span>\n              )}\n            </div>\n            <Label htmlFor={`${id}-to`} className=\"sr-only\">\n              to\n            </Label>\n            <div className=\"relative\">\n              <Input\n                key={`${id}-to-${range[1]}`}\n                id={`${id}-to`}\n                type=\"number\"\n                aria-label={`${label} maximum value`}\n                aria-valuemin={min}\n                aria-valuemax={max}\n                inputMode=\"numeric\"\n                pattern=\"[0-9]*\"\n                placeholder={max.toString()}\n                min={min}\n                max={max}\n                defaultValue={range[1]}\n                onChange={event =>\n                  onRangeValueChange(String(event.target.value))\n                }\n                className={cn(\"h-8 w-24\", unit && \"pr-8\")}\n              />\n              {unit && (\n                <span className=\"absolute top-0 right-0 bottom-0 mt-0.5 mr-0.5 flex h-7 items-center rounded-r-md bg-accent px-2 text-sm text-muted-foreground\">\n                  {unit}\n                </span>\n              )}\n            </div>\n          </div>\n          <Label htmlFor={`${id}-slider`} className=\"sr-only\">\n            {label} slider\n          </Label>\n          <Slider\n            id={`${id}-slider`}\n            min={min}\n            max={max}\n            step={step}\n            value={range}\n            onValueChange={onSliderValueChange}\n          />\n        </div>\n        <Button\n          aria-label={`Clear ${label} filter`}\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={onReset}\n        >\n          Clear\n        </Button>\n      </PopoverContent>\n    </Popover>\n  )\n}\n\n/**\n * @required displayName is required for auto feature detection\n * @see \"feature-detection.ts\"\n */\n\nTableSliderFilter.displayName = \"TableSliderFilter\"\n",
      "type": "registry:component",
      "target": "components/niko-table/filters/table-slider-filter.tsx"
    }
  ],
  "type": "registry:component"
}